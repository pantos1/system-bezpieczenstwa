\documentclass[a4paper,11pt,twoside]{article}
\renewcommand{\familydefault}{\sfdefault}
\addtolength{\hoffset}{-1.54cm}
\setlength{\oddsidemargin}{2cm}
\setlength{\textwidth}{16cm}

\addtolength{\voffset}{-1in}
\setlength{\topmargin}{1.5cm}
\setlength{\headheight}{5mm}
\setlength{\headsep}{5mm}
\setlength{\textheight}{247mm}
\setlength{\footskip}{1cm}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{polski}
\usepackage{listings}
\usepackage{graphicx} 
\usepackage{color}
\usepackage{helvet}
\usepackage{courier}
\usepackage{pdfpages}
\usepackage{multirow}
\usepackage{hyperref}
\usepackage{float}
\usepackage{textgreek}
\usepackage[font={small}]{caption}
\renewcommand*{\tablename}{Tabela}
\renewcommand*{\figurename}{Rys.} 
\renewcommand{\baselinestretch}{1.15} 

\usepackage{fancyhdr}
\fancypagestyle{plain}{
\fancyhead{}
\cfoot{}
\fancyfoot[LE, RO]{\thepage}}
\renewcommand{\headrulewidth}{0pt}

\pagestyle{plain}

\usepackage{tocloft}
\makeatletter
\renewcommand*\@seccntformat[1]{\csname the#1\endcsname.\enspace}
\makeatother
\renewcommand{\cftsecaftersnum}{.}
\renewcommand{\cftsubsecaftersnum}{.}
\renewcommand{\cftsubsubsecaftersnum}{.}
\renewcommand{\cftparaaftersnum}{.}
\renewcommand{\cftsubparaaftersnum}{.}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ 
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}; should come as last argument
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  %deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  %frame=single,	                   % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  morekeywords={*,self},            % if you want to add more keywords to the set
  numbers=none,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,	                   % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}
\lstdefinelanguage{JavaScript}{
  keywords={async, await, break, case, catch, const, continue, debugger, default, delete, do, else, finally, for, function, if, in, instanceof, let, new, return, switch, this, throw, try, typeof, var, void, while, with},
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]',
  morestring=[b]",
  sensitive=true
}

\begin{document}

\includepdf[pages=-]{title.pdf}

\tableofcontents
\setcounter{tocdepth}{2}
\newpage

\section{Wstęp teoretyczny}

\subsection{Współczesne systemy monitoringu i bezpieczeństwa}

\subsection{Koncepcja "inteligentnego domu"}

\subsection{Motywacje i cel pracy}

\newpage
\section{Architektura systemu}

\subsection{Wymagania techniczne i funkcjonalne}
System bezpieczeństwa powinien łączyć funkcję monitoringu z możliwością kontroli otwarcia drzwi i okien oraz pomiaru warunków środowiskowych. Monitoring powinien być zrealizowany poprzez kamery USB ze względu na ich cenę i dostępność. System powinien być skalowalny i umożliwiać rozbudowę o dodatkowe kamery, co odpowiada np. rozszerzeniu monitoringu o dodatkowe pomieszczenia. Dane zebrane przez system należy udostępnić przez graficzny interfejs użytkownika w postaci strony WWW. Podłączenie systemu do sieci domowej LAN (ang. \textit{Local Area Network}) i wykonanie odpowiednich ustawień w panelu administracyjnym rutera umożliwi dostęp do strony WWW z dowolnego miejsca przez Internet.

System powinien być zrealizowany w postaci komputera jednopłytkowego z systemem Linux, na którym będzie działał serwer WWW. Odpowiada on za dostęp do strony WWW i danych zebranych przez system. Kontrolę otwarcia drzwi i okien można zrealizować poprzez czujniki stykowe, które należy podłączyć do wyprowadzeń GPIO. Dostępne na rynku zintegrowane czujniki warunków środowiskowych (np. temperatury i wilgotności) wymagają obsługi magistral (np. I2C czy OneWire). Komputer powinien być wyposażony w gniazda USB, do których będą podłączone kamery. Monitoring przy pomocy kamer nie musi być prowadzony w postaci ciągłego nagrania, które wymaga sporej ilości miejsca w pamięci. Wystarczające będzie okresowe wykonywanie zdjęć oraz dodatkowo wyzwalanie zdjęcia w przypadku otwarcia drzwi lub okna -- otwarcia czujnika stykowego przypisanego do kamery. 

Interfejs użytkownika musi prezentować aktualny stan systemu w postaci dostępu do ostatnich wykonanych zdjęć, odczytów czujników środowiskowych oraz stanu czujników stykowych (otwarty/zamknięty). Ponadto użytkownik powinien mieć dostęp do przeszłych zdjęć i pomiarów w postaci archiwum. Historia odczytów systemu powinna być również dostępna w formie eksportowanej listy np. w formacie \textit{csv}. Użytkownik powinien mieć również możliwość dokonania zmian ustawień systemu przez panel administracyjny. Może on umożliwiać np. włączenie wysyłania powiadomień e-mail w przypadku otwarcia czujnika.

Dane zebrane przez system z kamer i czujników powinny być więc zapisane w systemie tak, by umożliwić do nich dostęp serwerowi WWW, na którym będzie działać strona WWW. Pomiary wykonywane przez system powinny być zapisywane wraz z datą i godziną ich wykonania. Dostęp do tych danych powinien być niezależny od programu zapisującego wyniki pomiarów i prowadzącego monitoring.

Podsumowując, wymagania techniczne stojące przed systemem to:
\begin{itemize}
\item wykorzystanie komputera jednopłytkowego,
\item użycie systemu Linux,
\item użycie serwera WWW,
\item obsługa wielu kamer USB,
\item obsługa wielu dwustanowych czujników stykowych poprzez wyprowadzenia GPIO,
\item obsługa wielu czujników środowiskowych korzystających np. z I2C lub OneWire,
\item możliwość połączenia z Internetem poprzez Ethernet lub Wi-Fi.
\end{itemize}

Wymagania funkcjonalne systemu to:
\begin{itemize}
\item dostęp do stanu systemu poprzez stronę WWW,
\item dostęp do archiwalnych stanów systemu,
\item możliwość eksportu listy pomiarów i zdarzeń do pliku (np. w formacie \textit{csv}),
\item dostęp do ustawień systemu poprzez interfejs użytkownika,
\item wysyłanie powiadomień e-mail w przypadku otwarcia czujnika,
\item wywoływanie zdjęcia po otwarciu czujnika.
\end{itemize}

Na podstawie powyższych wymagań opracowana została architektura systemu, którą jest przedstawiona na rysunku \ref{fig: architektura} i zostanie omówiona w poniższych podrozdziałach.
\begin{figure}[h]
\includegraphics[width=\linewidth]{architektura.png}
\caption{Architektura systemu bezpieczeństwa.}
\label{fig: architektura}
\end{figure}


\subsection{Przegląd dostępnych platform}
Jednymi z najbardziej popularnych komputerów jednopłytkowych jest Raspberry Pi rozwijany przez Raspberry Pi Foundation jako narzędzie edukacyjne do nauczania programowania i elektroniki. Wokół tego projektu powstała duża grupa amatorów i entuzjastów dzielących się swoimi projektami. Jednym z konkurentów Raspberry Pi jest BeagleBone rozwijany przez Texas Instruments również zgodnie z filozofią \textit{open-hardware} -- sprzętu o otwartym dostępie do źródła i projektów. Oba komputery oparte są o procesory ARM Cortex w formie \textit{System On Chip} -- układu scalonego zawierającego procesor wraz z układami pamięci, peryferiami i przetwornikami analogowo-cyfrowymi i cyfrowo-analogowymi. Oba komputery umożliwiają zainstalowanie na nich dystrybucji systemu Linux. Najnowszymi modelami w momencie rozpoczęcia projektu (w marcu 2017 roku) były Raspberry Pi Model 3B oraz BeagleBone Black. Porównanie obu komputerów przedstawiono w tabeli \ref{porównanieSBC}.
\begin{table}[h]
\centering
\begin{tabular}{lll}
\hline \noalign{\vskip 2mm}
                         & Raspberry Pi 3B & BeagleBone Black \\ \hline \noalign{\vskip 2mm}
Rok wydania              & 2016            & 2013             \\
CPU                      & ARM Cortex-A53  & ARM Cortex-A8    \\
Liczba rdzeni            & 4               & 1                \\
Częstotliwość taktowania & 1,2 GHz         & 1 GHz            \\
RAM                      & 1 GB LPDDR2     & 512 MB DDR3L     \\
Liczb gniazd USB         & 4               & 1                \\
WLAN                     & b/g/n           & brak             \\
Ethernet                 & 10/100          & 10/100           \\
I2C                      & Tak             & Tak              \\
Liczba wyprowadzeń GPIO  & 40              & 66               \\
Maksymalny pobór mocy 	 & 3 W             & 2,3 W            \\ \hline
\end{tabular}
\caption{Porównanie specyfikacji technicznej Raspberry Pi 3B i BeagleBone Black \cite{rpi} \cite{bb_black} \cite{porownanie_wiki}}
\label{porównanieSBC}
\end{table}

Przewagą komputera Raspberry Pi 3B jest szybszy procesor o większej liczbie rdzeni, co pozwala na równoległe wykonywanie większej liczby procesów, oraz większa pojemność pamięci RAM. Ponadto ma on możliwość podłączenia zarówno do sieci przewodowej (Ethernet) jak i bezprzewodowej (WLAN). Może być to przewaga w przypadku, gdyby system miał być zainstalowany z daleka od rutera. Komputer BeagleBone Black ma niższą wartość poboru mocy oraz więcej wyprowadzeń GPIO. Na każdy czujnik stykowy będzie jednak potrzebne jedno wyprowadzenie GPIO oraz podłączenie do masy, zatem 40 wyprowadzeń Raspberry Pi 3B z pewnością będzie wystarczające. Z tych powodów wybrałem platformę Raspberry Pi 3B do projektowanego systemu.

Wśród dostępnych dystrybucji systemu Linux na Raspberry Pi są m.in. Raspbian (domyślna dystrybucja oparta o Debian) i Ubuntu Mate. W projekcie zostanie użyty system Raspbian, ponieważ jest on uniwersalny i spełnia wszystkie stawiane wymogi -- obsługę wyprowadzeń GPIO, magistrali I2C oraz możliwość działania jako serwer WWW (np. przy użyciu Apache). System Raspbian posiada również interfejs graficzny, co może być przydatną cechą w przypadku, gdyby konieczna była bezpośrednia interwencja administratora systemu z pominięciem stworzonego interfejsu użytkownika.

\subsection{Czujniki warunków środowiskowych}
Wymogiem technicznym systemu jest również obsługa czujników środowiskowych. Najważniejszymi parametrami, które należy zmierzyć w warunkach domowych są temperatura i wilgotność względna powietrza. Wpływają one na jakość powietrza w pomieszczeniach oraz na poziom zachorowań wśród przebywających w nich. Badania wykazały związek między wilgotnością względną w domu i pracy oraz liczbą dni spędzonych na zwolnieniu lekarskim. Zbyt niska lub zbyt wysoka wilgotność powietrza w pomieszczeniach prowadzi do zwiększenia przypadków zachorowań na choroby układu oddechowego. \cite{zachorowania} 

Przykładowymi czujnikami temperatury i wilgotności dostępnymi na rynku są Adafruit SHT31, Adafruit Si7021 oraz Grove TH02. Są to czujniki umieszczone na płytkach \textit{breakout-board}, które posiadają wyprowadzenia linii I2C, masy oraz zasilania. Porównanie specyfikacji czujników znajduje się w tabeli \ref{czujniki_temp}.

\begin{table}[h]
\centering
\begin{tabular}{lllllll}
\hline \noalign{\vskip 2mm}
       & \multicolumn{2}{c}{Temperatura} & \multicolumn{2}{c}{Wilgotność} &          \\ \cline{2-5} \noalign{\vskip 2mm}
       & Zakres pomiarowy  & Dokładność  & Zakres pomiarowy  & Dokładność & Cena     \\ \hline \noalign{\vskip 2mm}
SHT31  & $-$40 -- 125 $^\circ$C      & $\pm$ 0,3 $^\circ$C    & 0 -- 100\% RH      & $\pm$ 2 \%RH    & 79,80 zł \\
Si7021 & $-$10 -- 85 $^\circ$C       & $\pm$ 0,4 $^\circ$C    & 0 -- 80\% RH       & $\pm$ 3 \%RH    & 39,70 zł \\
TH02   & $-$40 -- 85 $^\circ$C         & $\pm$ 0,5 $^\circ$C    & 0 -- 80\% RH       & $\pm$ 4,5 \%RH                  & 54,00 zł \\
\hline
\end{tabular}
\caption{Porównanie specyfikacji czujników temperatury i wilgotności \cite{czujnik_temp} \cite{sht31} \cite{th02} (ceny za sztukę: \url{www.botland.com.pl}).}
\label{czujniki_temp}
\end{table}

Na podstawie danych przedstawionych w tabeli \ref{czujniki_temp} wybrałem czujnik Si7021 jako użyty w projekcie czujnik środowiskowy. Zapewnia on pomiar temperatury i wilgotności względnej w zakresie wartości panujących w warunkach pokojowych oraz ma najniższą cenę. Przewagą czujnika SHT31 była możliwość zmiany adresu I2C poprzez podłączenie wyprowadzenia do stanu wysokiego lub niskiego. Byłoby to jednak rozwiązanie możliwe do zastosowania przy użyciu tylko dwóch czujnikach w systemie. 

\subsection{Czujniki stykowe}
Magnetyczne czujniki zbliżeniowe mogą być użyte do określenia pozycji drzwi lub okien i tym samym realizować nadzór nad ich stanem. Czujniki te posiadają dwa stany -- zamknięty i otwarty. W systemie zostały użyte czujniki zbliżeniowe MC-38 składające się z kontaktronu i magnesu. Obwód kontaktronu jest domyślnie rozwarty, a po zbliżeniu magnesu następuje jego zamknięcie i przepływ prądu. Wybrałem ten czujnik ze względu na łatwość ewentualnego montażu -- czujnik posiada taśmę samoprzylepną i otwory na śruby montażowe.

\subsection{Kamery cyfrowe}
Kamery USB zastosowane w systemie mogą pozwolić na realizację domowego monitoringu niedużym kosztem. Ich uniwersalność pozwala również wykorzystać je w innych domowych zastosowaniach np. jako kamerę do rozmów przez komunikatory internetowe takie jak Skype czy Google Hangouts. W projektowanym systemie zadaniem kamer będzie cykliczne wykonywanie zdjęć. Celem powinno być znalezienie złotego środka między jakością zdjęć wykonywanych przez kamery i ich ceną. Jakość powinna być na tyle dobra, by zdjęcie umożliwiło identyfikację ewentualnego intruza. Koszt jest kategorią bardziej subiektywną, ale kamera USB powinna być konkurencyjna cenowo wobec kamer IP, których koszt zaczyna się od ok. 150 zł.\cite{komputer_świat}

W systemie zastosowałem dwie kamery z różnego przedziału cenowego. Kamera Titanum Onyx posiada matrycę CMOS, która umożliwia wykonywanie zdjęć o rozdzielczości do 5 megapikseli przy zastosowaniu interpolacji. Co ważne kamera jest kompatybilna z UVC (\textit{USB Video Class}) -- sterownikiem wbudowanym w system Linux. Kamera posiada również przełącznik włączający 3 diody LED, które mogą być przydatne w przypadku zdjęć nocnych. Koszt kamery to ok. 50 zł. Drugą kamerą jest Creative VFO 790, która posiada matrycę wykonującą zdjęcia w rozdzielczości HD 720p (1280x720 pikseli). Jest ona również kompatybilna z UVC. Optyka kamery jest stałoogniskowa w przeciwieństwie do kamery Titanum Onyx. Koszt kamery to ok. 110 zł.

\subsection{Projekt części sprzętowej systemu}
Połączenie między komputerem Raspberry Pi 3B a dołączonymi czujnika zrealizowałem na prototypowej płytce stykowej. Umożliwia ona tworzenie prototypów bez konieczności lutowania połączeń. Połączenie między płytką prototypową a wyprowadzeniami GPIO Raspberry Pi jest wykonane przez ekspander wyprowadzeń ProtoPi Plus.

W systemie zostały zastosowane czujniki zbliżeniowe magnetyczne MC-38. Kontaktron został podłączony do wyprowadzenia GPIO poprzez wbudowany rezystor ściągający do masy (ang. \textit{pull-down}) oraz napięcia zasilania równego 3,3 V. Gdy kontaktron i magnes są zbliżone, obwód jest zamknięty i na wyprowadzeniu pojawia się wysoki stan. W przypadku oddalenia czujników i otwarcia obwodu na wyprowadzeniu pojawia się stan niski poprzez rezystor ściągający do masy. Na rysunku \ref{fig: kontaktron} został przedstawiony schemat podłączenia czujnika stykowego do platformy Raspberry Pi (z pominięciem ekspandera ProtoPi Plus).
\begin{figure}[h]
\includegraphics[width=0.5\linewidth]{kontaktron.png}
\includegraphics[width=0.5\linewidth]{kontaktron_zamkniety.png}
\caption{Schemat podłączenia czujnika MC-38 w przypadku oddalonego (lewo) i zbliżonego(prawo) magnesu.}
\label{fig: kontaktron}
\end{figure}

Wymogiem systemu jest również obsługa wielu kamer i czujników, w tym czujników temperatury i wilgotności poprzez magistralę I2C. Adres I2C wybranych do projektu czujników Si 7021 to 0x40. Nie mają one możliwości programistycznej lub sprzętowej zmiany adresu. Oznacza to, że do jednej magistrali mógłby być podłączony bezpośrednio tylko jeden czujnik. Podłączenie większej liczby czujników o tym samym adresie doprowadziłoby do sytuacji, w której nie można jednoznacznie określić, z którego czujnika został odczytany wynik pomiaru. Raspberry Pi3 B posiada możliwości obsługi dwóch magistral I2C. Oznaczałoby to jednak, że liczba czujników temperatury w systemie byłaby mniejsza niż kamer i czujników stykowych. Innym rozwiązaniem tego problemu jest zastosowanie multipleksera I2C. Multiplekser zadziała jak przełącznik, który pozwoli na komunikację z jednym czujnikiem naraz. Przykładem takiego urządzenia jest TCA 9548A firmy Adafruit. Pozwala on na podłączenie do 8 urządzeń korzystających z magistrali I2C.

Multiplekser TCA 9548A jest podłączony do wyprowadzeń GPIO2 i GPIO 3, które mogą być aktywowane jako odpowiednio linia SDA i SCL magistrali I2C. Ponadto wyprowadzenia GPIO2 i GPIO3 są podłączone przez wbudowane rezystory podciągające do napięcia zasilania 3,3 V\cite{rpi_schematic}, co jest zgodne z zaleceniami podanymi w karcie katalogowej.\cite{multiplekser} Multiplekser jest zasilany z wyprowadzenia 3,3 V platformy Raspberry Pi i podłączony do jej masy. Wyprowadzenia adresowe A2, A1 i A0 są podłączone do masy, co oznacza, że adres multipleksera to 0x70. Nieużywane wyprowadzenie $\overline{\mathsf{RESET}}$ jest z kolei podłączone do zasilania poprzez rezystor podciągajacy, który ogranicza pobór prądu.

Czujniki Si7021 są przyłączone do kanałów SDx i SCx, gdzie x jest numerem kanału od 0 do 7. W karcie katalogowej czujnika podany jest typowy schemat przyłączenia, w którym użyte są rezystory podciągające 10 k\textOmega\hspace{0.2em} linie SDA i SCL do napięcia zasilania. Producent multipleksera TCA 9548A podaje z kolei w karcie katalogowej wzór \ref{pullup} pozwalający na wyznaczenie minimalnej wartości rezystorów podciągających.\cite{multiplekser} Napięcie $\mathsf{V_{DPU}}$ jest napięciem linii sygnałowych, które jest równe napięciu zasilania $\mathsf{V_{CC}}$. Napięcie $\mathsf{V_{OL(max)}}$ to maksymalne napięcie wyjściowe, a prąd $\mathsf{I_{OL}}$ to prąd wyjściowy czujnika. Obie wartości są podane w karcie katalogowej czujnika Si7021.\cite{czujnik_temp}

\begin{equation} \label{pullup}
R_{p(min)} = \frac{V_{DPU} - V_{OL(max)}}{I_{OL}} = \frac{3,3 V - 0,6 V}{2,5 mA} = 1,08 k\Omega  
\end{equation} 

Im większa rezystancja rezystora podciągającego tym mniejszy pobór prądu. Rezystor podciągający tworzy wraz z pojemnością magistrali $\mathsf{C_{b}}$ filtr dolnoprzepustowy RC. Jego stała czasowa nie może być na tyle duża, że zbocza zostaną rozciągnięte w czasie tak, że ich czas narastania przekroczy wymagania czasowe magistrali. Pojemność magistrali jest trudna do zmierzenia, więc rezystancja powinna być zbliżona do minimalnej wymaganej. W ramach projektowanego systemu użyte zostały rezystory podciągające 2,2 k\textOmega. Rysunek \ref{fig: i2c_schemat} przedstawia schemat połączeń między komputerem Raspberry Pi a multiplekserem TCA 9548A i dwoma czujnikami Si7021. Przedstawiono dwa czujniki poglądowo -- system może być powiększony o dodatkowe czujniki.

\begin{figure}[h]
\includegraphics[width=\linewidth]{i2c.png}
\caption{Schemat podłączenia multipleksera TCA9548A i czujników Si7021.}
\label{fig: i2c_schemat}
\end{figure}

Podłączenie większej liczby kamer USB do Raspberry Pi może spowodować chwilowe przekroczenie dopuszczalnego poboru mocy z gniazd USB. Rozwiązaniem tego problemu jest użycie rozgałęziacza (ang. \textit{hub}) USB z zewnętrznym zasilaniem. Zwiększa on jednocześnie zasięg kamer podłączonych przewodowo kamer. Należy uważać jednak, by rozgałęziacz nie zasilał wstecznie (ang. \textit{backfeed}) komputera Raspberry Pi, ponieważ grozi to uszkodzeniem systemu. Z tego powodu w projekcie użyłem dedykowanego rozgałęziacza firmy The Pi Hut.

\newpage
\section{Obsługa kamer i czujników}
Do napisania programu obsługującego czujniki i kamery wybrałem język Python, ponieważ umożliwia on poprzez wiele dostępnych modułów wysokopoziomową obsługę wyprowadzeń GPIO, magistrali I2C oraz kamer USB. Ponadto istnieje wiele pakietów pozwalających na łatwą komunikację z bazą danych, która będzie miejscem przechowywania wyników pomiaru. Program w języku Python jest też odpowiedzialny za wysłanie powiadomień email poprzez serwer SMTP Google. Na potrzeby projektu zostało stworzone konto w usłudze Gmail, przez które będą wysyłanie powiadomienia. 

Zadaniem programu nadzor.py jest cyklicznie wykonywanie pomiarów, odczytów i zdjęć oraz zapis wyników do bazy danych. Potrzebne jest narzędzie, które pozwoli okresowo wykonywać funkcje w ramach jednego programu. Wewnątrz języka Python istnieją mechanizmy (moduł \texttt{sched}), które umożliwiają wykonywanie zadań po minięciu pewnego czasu lub zaplanowanie ich do wykonania o konkretnej porze. Wykorzystanie tego modułu wymagałoby jednak ponownego zaplanowania zadania po każdym jego wykonaniu. Modułem, który umożliwia dokonanie tego w prostszy sposób, jest biblioteka \texttt{schedule}. Jest ona przeznaczona do planowania cyklicznego wykonywania zadań. Przykładowe wywołanie szeregowania przy użyciu biblioteki \texttt{schedule} przedstawiono poniżej.
\begin{lstlisting} [language=Python]
schedule.every(kamera.czestotliwosc_zdjecia).seconds.do(grupa.zrob_zdjecie)
\end{lstlisting}
Jako argument \texttt{every()} podawana jest częstotliwość wykonywania zadania, następnie podawane są jednostki oraz nazwa uruchamianej funkcji jako argument \texttt{do()}.

\begin{figure}[H]
\begin{center}
\includegraphics[width=0.5\linewidth]{Grupa.png}
\caption{Diagram UML klasy Grupa}
\label{fig: Grupa}
\end{center}
\end{figure}

Rysunek \ref{fig: Grupa} przedstawia strukturę klasy Grupa. Skrótem \textit{m} oznaczone są metody klasy, a \textit{f} - atrybuty. Działanie poszczególnych metod jest opisane w poniższych podrozdziałach. 

Program jest napisany przy użyciu metodyki obiektowej. Takie podejście pozwala powiązać czujnik z kamerą, która będzie wykonywała zdjęcia w przypadku zmiany stanu. Klasa Grupa reprezentuje czujnik i kamerę oraz dodatkowo przypisany do nich czujnik temperatury. Zawiera ona metody, które wykonują zdjęcie, pomiar temperatury i wilgotności oraz odczyt stanu wyprowadzenia GPIO, do którego jest dołączony czujnik stykowy. Zarządza ona również wysłaniem wiadomości email z powiadomieniem w przypadku zmiany stanu czujnika.

\subsection{Obsługa kamer USB}
Kamery USB są obsługiwane przez metodę \texttt{wyslij{\_}email}. Do samego wykonywania zdjęć użyta jest aplikacja \texttt{fswebcam}. Jest to samodzielny program pozwalający na pobieranie zdjęć z kamer USB podłączonych do komputera z systemem typu Linux. Program ten pozwala na wykonanie zdjęcia z określonej kamery, zdefiniowane rozdzielczości zdjęcia, umieszczenie na zdjęciu podpisu z bieżącą datą i godziną. 

Wywołanie programu \texttt{fswebcam} z poziomu programu w języku Python wymaga użycia modułu \texttt{subprocessing}. Daje on możliwość otwierania programów w osobnych procesach. W tym przypadku użyta została klasa \texttt{Popen} z tego modułu, otwierająca nowy podproces. Klasa jest dostępna zarówno w wersji języka Python 2 jak i 3. Tworząc obiekt klasy, należy przekazać do niego listę składającą się z nazwy programu, który chcemy uruchomić i jego argumentów. Dodatkowo można określić, czy i gdzie kierować informacje ze standardowych strumieni wejścia/wyjścia procesu:

\begin{lstlisting} [language=Python]
proces = Popen(["fswebcam", "-q", "-d/dev/video0", "-r 640x480", "/var/www/html/img/2018-05-24 22:32:10.jpg"], stdout=PIPE, stderr=PIPE)
\end{lstlisting}

Użytymi argumentami programu \texttt{fswebcam} w powyższym przykładowym wywołaniu są:
\begin{itemize}
\item \texttt{-r} -- rozdzielczość , 
\item \texttt{-d} -- nazwa wirtualnego węzła kamery,
\item \texttt{-q} -- tryb cichy,
\item ścieżka, gdzie ma być zapisany plik z wykonanym zdjęciem.
\end{itemize}
Standardowe strumienie wyjścia i błędów są przekierowane do obiektów \texttt{pipe}, dzięki czemu ich wartość będzie można następnie odczytać. Program \texttt{fswebcam} domyślnie przekierowuje wszystkie komunikaty do strumienia błędów. Użycie trybu cichego zapewnia, że w strumieniu błędów znajdzie się jedynie informacja o błędach.

Zdjęcie jest zapisywane w formacie JPG w rozdzielczości 640x480 pikseli. Jest to maksymalna możliwa rozdzielczość zastosowanej kamery Titanum Onyx. Kolejną komendą jest nazwa wirtualnego węzła kamery (ang. \textit{virtual device node}). Jest to plik, który system Linux tworzy podczas uruchomienia i który jest przypisany do konkretnego urządzenia. Plik ten jest przechowywany w folderze \texttt{/dev}. Dzięki użyciu wirtualnego węzła możliwe jest wskazanie konkretnej kamery do wykonania zdjęcia. Zdjęcie jest zapisywane w miejscu wskazanym przez atrybut klasy Grupa o nazwie sciezka. Do przekazywanej do programu ścieżki dołączana jest nazwa zdjęcia w postaci daty zaplanowania jego wykonania. Format daty to "'rok-miesiąc-dzień godzina:minuta:sekunda"' i stanowi unikalny identyfikator zdjęcia. Jest to możliwe, ponieważ w jednej chwili czasu działa wyłącznie jedno wywołanie funkcji \texttt{wyslij{\_}zdjecie()}.

Po wywołaniu procesu funkcja oczekuje na jego wykonanie i odbiera informacje ze strumienia wyjścia i błędów przy pomocy metody \texttt{communicate()}. Jeśli zawartość strumienia błędów nie jest pusta, podniesiony jest wyjątek \texttt{IOError}. Obsługa wyjątku polega na zapisie wartości pustej (\texttt{None}) do zmiennej \texttt{nazwa}, która zostanie użyta do stworzenia nowego wpisu w bazie danych. Poprawnie wykonane zdjęcie jest więc oznaczane nazwą pliku ze zdjęciem, a niepoprawne -- wartością pustą.
\subsection{Obsługa czujników podłączonych do magistrali I2C}
\subsubsection{Komunikacja z multiplekserem TCA9548A}
Multiplekser TCA9548A umożliwia przyłączenie do 8 urządzeń korzystających z magistrali I2C. Użyte czujniki temperatury i wilgotności Si 7021 posiadają taki sam adres, więc multiplekser powinien być skonfigurowany do zestawienia komunikacji z każdym z nich osobno. Aktywacja pojedynczego kanału odbywa się poprzez przesłanie do multipleksera 8 bitowego kodu odpowiadającego numerowi kanału. Kod ten tworzony jest przez ustawienie bitu o pozycji równej numerowi kanału jako 1. Pozostałe pola powinny być ustawione jako 0. Operację tą wykonuje pomocnicza funkcja \texttt{kanal}. Zwraca ona 8-bitową komendę odpowiadającą numerowi kanału. Definicja kodu została pokazana w tabeli \ref{command_byte}. Po wysłaniu przez I2C komendy i znaku STOP kanał jest aktywowany. Dalsze komendy I2C można już adresować, używając adresu czujnika temperatury.
\begin{table}[h]
\centering
\begin{tabular}{|llllllll|l|}
\hline
\multicolumn{8}{|l|}{Bity rejestru sterującego}                                                                                                                                                                                                                                                                                                                                                & \multicolumn{1}{c|}{\multirow{2}{*}{Działanie}}                              \\ \cline{1-8}
B7                                          & B6                                            & B5                                            & B4                                            & B3                                            & B2                                            & B1                                            & \multicolumn{1}{l}{B0}                       & \multicolumn{1}{|c|}{}                                                        \\ \hline 
X                                             & X                                             & X                                             & X                                             & X                                             & X                                             & X                                             & \begin{tabular}[c]{@{}l@{}}0\\ 1\end{tabular} & \begin{tabular}[c]{@{}l@{}}Kanał 0 nieaktywny\\ Kanał 0 aktywny\end{tabular} \\ \hline
X                                             & X                                             & X                                             & X                                             & X                                             & X                                             & \begin{tabular}[c]{@{}l@{}}0\\ 1\end{tabular} & X                                             & \begin{tabular}[c]{@{}l@{}}Kanał 1 nieaktywny\\ Kanał 1 aktywny\end{tabular} \\ \hline
X                                             & X                                             & X                                             & X                                             & X                                             & \begin{tabular}[c]{@{}l@{}}0\\ 1\end{tabular} & X                                             & X                                             & \begin{tabular}[c]{@{}l@{}}Kanał 2 nieaktywny\\ Kanał 2 aktywny\end{tabular} \\ \hline
X                                             & X                                             & X                                             & X                                             & \begin{tabular}[c]{@{}l@{}}0\\ 1\end{tabular} & X                                             & X                                             & X                                             & \begin{tabular}[c]{@{}l@{}}Kanał 3 nieaktywny\\ Kanał 3 aktywny\end{tabular} \\ \hline
X                                             & X                                             & X                                             & \begin{tabular}[c]{@{}l@{}}0\\ 1\end{tabular} & X                                             & X                                             & X                                             & X                                             & \begin{tabular}[c]{@{}l@{}}Kanał 4 nieaktywny\\ Kanał 4 aktywny\end{tabular} \\ \hline
X                                             & X                                             & \begin{tabular}[c]{@{}l@{}}0\\ 1\end{tabular} & X                                             & X                                             & X                                             & X                                             & X                                             & \begin{tabular}[c]{@{}l@{}}Kanał 5 nieaktywny\\ Kanał 5 aktywny\end{tabular} \\ \hline
X                                             & \begin{tabular}[c]{@{}l@{}}0\\ 1\end{tabular} & X                                             & X                                             & X                                             & X                                             & X                                             & X                                             & \begin{tabular}[c]{@{}l@{}}Kanał 6 nieaktywny\\ Kanał 6 aktywny\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}0\\ 1\end{tabular} & X                                             & X                                             & X                                             & X                                             & X                                             & X                                             & X                                             & \begin{tabular}[c]{@{}l@{}}Kanał 7 nieaktywny\\ Kanał 7 aktywny\end{tabular} \\ \hline
\end{tabular}
\caption{Definicja bajtu sterującego. Źródło: \cite{multiplekser}}
\label{command_byte}
\end{table}

\subsubsection{Komunikacja z czujnikiem Si7021}
Komunikacja z czujnikiem Si7021 odbywa się przez magistralę I2C. Pierwszą komendą, którą należy wysłać do czujnika, jest komenda wykonania pomiaru wilgotności względnej. W dokumentacji czujnika Si7021 opisane są dwie metody pomiaru - Hold Master Mode oraz No Hold Master Mode. Ich porównanie zostało przedstawione na rysunku \ref{fig: metody_pomiaru}. Kolorem białym są oznaczone komendy i dane wysyłane przez urządzenie nadrzędne (ang. \textit{master}), a szarym przez urządzenie podrzędne (ang. \textit{slave}). W pierwszej z nich urządzenie nadrzędne wysyła żądanie pomiaru (\textit{Measure Cmd}). Po potwierdzeniu odbioru wysyłane jest żądanie odczytu (\textit{R}). Urządzenie podrzędne potwierdza otrzymanie żądania i dokonuje pomiaru. Wymaga to zastosowania rozciągania zegara (ang. \textit{clock stretching}), które polega na utrzymywaniu przez urządzenie podrzędne linii zegarowej SCK w stanie niskim. Dzieje się to aż do momentu zakończenia pomiaru przez urządzenie i wpisaniu jego wyniku do rejestru. Wynik pomiaru składa się z dwóch bajtów, które należy odebrać w jednej transakcji. Ostatecznie komunikacja kończy się poprzez wystawienie znaku STOP (\textit{P}). Drugi tryb pomiaru (No Hold Master Mode) różni się tym, że po wysłaniu kodu pomiaru (0xF5) oraz żądania odczytu urządzenie nie potwierdza odbioru aż do momentu zakończenia pomiaru. Następnie należy odczytać dwubajtowy wynik pomiaru z rejestru czujnika.

\begin{figure}[H]
\begin{center}
\includegraphics[width=0.8\linewidth]{Si7021_pomiar.png}
\caption{Porównanie sekwencji komend I2C do wykonania pomiaru czujnikiem Si7021. Źródło: \cite{czujnik_temp}}
\label{fig: metody_pomiaru}
\end{center}
\end{figure}

Do programowej komunikacji przez I2C potrzebna była odpowiednia biblioteka. Pierwszym zastosowanym modułem był moduł \texttt{python-smbus}. Korzysta on ze sterownika wbudowanego w jądro systemu Linux. Do przeprowadzenia pomiaru w trybie Hold Master Mode można użyć funkcji \texttt{i2c{\_}smbus{\_}read{\_}word{\_}data()} \linebreak lub \texttt{i2c{\_}smbus{\_}read{\_}i2c{\_}block{\_}data()}. Obie funkcje są zgodne z przedstawioną powyżej sekwencją pomiaru, lecz różnią się liczbą odebranych bajtów. Pierwsza funkcja odbiera dokładnie dwa bajty, a druga odbiera bajty z urządzenia do momentu zakończenia komunikacji przez urządzenie podrzędne\cite{smbus}. Próba przeprowadzenia pomiaru przy ich użyciu zakończyła się błędem o kodzie \texttt{io errno5}. Wynikał on z tego, że pakiet \texttt{python-smbus} obsługuje magistralę I2C zgodnie ze standardem SMBus -- rozszerzeniem I2C. Posiada on bardziej ścisłe reguły dotyczące czasu trwania transakcji na magistrali. Obie wymienione funkcje odczytu pakietu \texttt{python-smbus} są poprzedzone wysłaniem żądania do urządzenia. Oznacza to, że nie można przy ich pomocy odczytać samego wyniku pomiaru po wysłaniu kodu pomiaru w trybie No Hold Master Mode (0xE5). Inna dostępna funkcja \texttt{i2c{\_}smbus{\_}read{\_}byte()} pozwala na odczyt wyłącznie jednego bajtu. Dwukrotne wysłanie żądania przy pomocy tej funkcji prowadzi do dwukrotnego odczytania pierwszego bajtu pomiaru. Z tych powodów moduł \texttt{python-smbus} nie może zostać wykorzystany do obsługi czujnika Si7021. 

Innym pakietem umożliwiającym komunikację poprzez magistralę I2C jest moduł \texttt{pigpio}. Umożliwia on obsługę wyprowadzeń GPIO na platformi Raspberry Pi w tym tych, które są skonfigurowane jako magistrala I2C. Opiera on swoje działanie na bibliotece napisanej w języku C. Przed rozpoczęciem działania pakietu konieczne jest uruchomienie programu \texttt{pidpiod}. Jest to demon -- program działający w tle bez interakcji z użytkownikiem. Musi on działać, zanim wywołany zostanie program \texttt{nadzor.py}. Można to zapewnić, korzystając z narzędzia \texttt{cron}. Wpis do jego tabeli z wywołaniem programu \texttt{pigpiod} poprzedzony atrybutem \texttt{@reboot} umieszczony przed podobnym wpisem programu \texttt{nadzor.py} zapewnia, że program zostanie uruchomiony za każdym razem, gdy uruchamiany będzie system operacyjny.

Pierwszym krokiem jest stworzenie obiektu klasy \texttt{pigpio.pi}. Obiekt ten jest przechowywany jako atrybut \textit{i2c} klasy Grupa. Następnie konieczne jest otwarcie komunikacji z urządzeniem i zwrócenie identyfikatora, który będzie używany do wysyłania żądań do urządzeń. Funkcje tego modułu umożliwiają przeprowadzenie pomiaru wilgotności względnej w trybie \textit{No Hold Master Mode}. W pierwszej kolejności wysyłana jest 8-bitowa komenda pomiaru przy pomocy funkcji \texttt{i2c{\_}write{\_}byte()}. Realizuje ona sekwencję pomiaru do momentu potwierdzenia odbioru komendy przez urządzenie podrzędne. Następnie urządzenie oczekuje znaku powtórzonego startu (\textit{Sr}). Dopuszczalne jest jednak również przesłanie znaku STOP i zakończenie komunikacji.

Następnie program jest usypiany na czas 0.05s przy pomocy komendy \texttt{time.sleep()}. Jest to wartość większa niż najdłuższy czas konwersji pomiaru wilgotności względnej podany w karcie katalogowej czujnika Si 7021.\cite{czujnik_temp} W tym czasie wykonywany jest pomiar i można przejść do tej części procedury, która składa się z wysłaniu bitu odczytu (\textit{R}) i odebrania dwóch bajtów wyniku pomiaru. Można to zrealizować poprzez funkcję \texttt{i2c{\_}read{\_}device()}\cite{i2c_read_device}. Funkcja zwraca liczbę odczytanych bajtów oraz odczytane bajty w formie tablicy. Bajty te można następnie wykorzystać do obliczenia wilgotności względnej na podstawie wzoru \ref{RH} podanego w karcie katalogowej.\cite{czujnik_temp} ${Kod_{RH}}$ oznacza tablicę bajtów, do której został zapisany wynik pomiaru.
\begin{equation} \label{RH}
\%RH = \frac{(Kod_{RH}[0] * 256 + Kod_{RH}[1]) * 125}{65536} - 6  
\end{equation}

Czujnik Si 7021 wykonuje pomiar temperatury w ramach procedury wyznaczenia wilgotności względnej. Wynik tego pomiaru jest przechowywany w urządzeniu. Można go odczytać, wysyłając komendę o kodzie 0xE0. Całą transakcję można zrealizować przy użyciu funkcji \texttt{i2c{\_}read{\_}i2c{\_}block{\_}data} bez obawy o rozciąganie zegara, ponieważ nie ma potrzeby oczekiwania na wykonanie pomiaru temperatury. Dwa bajty wyniku pomiaru są zapisane do tablicy i użyte do obliczenia wartości temperatury na podstawie wzoru \ref{Temperatura}.\cite{czujnik_temp}
\begin{equation} \label{Temperatura}
Temperatura ({^\circ}C) = \frac{(Kod_{temp}[0] * 256 + Kod_{temp}[1]) * 175,72}{65536} - 46,85  
\end{equation}

Obsługa wyjątków w komunikacji przy użyciu magistrali I2C jest przeprowadzona poprzez wypisanie do konsoli komunikatu o typie urządzenia, dla którego nastąpił błąd (multiplekser albo czujnik). W takim wypadku wartościom temperatury i wilgotności są przypisywane wartości \texttt{None}. Są one następnie zapisane w bazie danych. Jeżeli natomiast nie wystąpiły błędy, w bazie danych zapisywane są obliczone wartości temperatury i wilgotności.

\subsection{Obsługa czujników stykowych}
Korzystanie z wyprowadzeń GPIO w języku Python na komputerze Raspberry Pi jest możliwe przy użyciu pakietu \texttt{RPi.GPIO}. Umożliwia on odczyt stanu wyprowadzeń. Konfiguracja obsługi GPIO rozpoczyna się od określenia sposobu numeracji wyprowadzeń. Dostępne są dwie możliwości: GPIO.BOARD oraz GPIO.BCM. Pierwszy odnosi się do fizycznej lokalizacji wyprowadzeń na płytce drukowanej. Drugi sposób oznacza numerację kanałów zgodną z układem system-on-chip (SOC) firmy Broadcom, który jest użyty w komputerze Raspberry Pi 3B. Ze względu na korzystanie z płytki prototypowej oraz modułu Proto Pi Plus, który korzysta z oznaczeń odpowiadających kanałom SOC, w projekcie użyto tego właśnie sposobu numeracji.

Inicjalizacja obsługi GPIO wywoływana jest w funkcji:  
\begin{lstlisting} [language=Python]
def init_gpio():
    GPIO.setmode(GPIO.BCM)
\end{lstlisting}
Wykonywana jest ona na początku działania programu \texttt{nadzor.py} w funkcji \texttt{main()}. Obsługa poszczególnych czujników odbywa się w ramach obiektów klasy Grupa. Aktywacja rezystora ściągającego (ang. \textit{pull-down}) do masy jest wywoływana w programie \texttt{nadzor.py} w konstruktorze obiektu klasy Grupa w następujący sposób:
\begin{lstlisting} [language=Python]
GPIO.setup(self.czujnik.gpio, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)
\end{lstlisting}
Pierwszym argumentem tej funkcji jest numer wyprowadzenia GPIO, drugi określa, czy wyprowadzenie ma być skonfigurowane jako wejście (\texttt{GPIO.IN}) czy wyjście (\texttt{GPIO.OUT}). Trzeci argument to znacznik określający, czy ma zostać użyty rezystor ściągający do masy czy podciągający do napięcia zasilania (ang. \textit{pull-up}).

Funkcja realizująca obsługę czujników stykowych zaczyna od sprawdzenia wyprowadzenia o numerze przechowywanym jako atrybut klasy. Zwrócenie stanu wysokiego (oznaczanego jako \texttt{1/GPIO.HIGH/True}) oznacza przypisanie do zmiennej \texttt{stan{\_}czujnika} wartości 1. Jeśli natomiast stan jest niski, to zmiennej przypisywana jest wartość 0. Następnie sprawdzany jest poprzedni stan wyprowadzenia przechowywany jako atrybut obiektu klasy Grupa. Jeśli poprzednio stan był wysoki (styki czujnika był zamknięte), to znaczy, że nastąpiło otwarcie czujników. Zgodnie z wymogami projektowanego systemu następuję wtedy wykonanie zdjęcia - funkcji obsługującej kamery. Na koniec program przechodzi do wysłania powiadomienia e-mail.

\subsection{Wysyłanie powiadomień e-mail}
Funkcjonalnością systemu jest również wysyłanie powiadomienia mailowego po otwarciu czujnika. Jest ono wysyłane przez serwer SMTP Google. Ta decyzja projektowa wynika z tego, że konfiguracja serwera SMTP działającego na Raspberry Pi wymagałaby posiadania stałego adresu IP dostarczanego przez dostawcę usług internetowych oraz domeny przypisanej do tego adresu. Prostszym rozwiązaniem jest utworzenie konta e-mail w zewnętrznej usłudze (np. Gmail) i korzystanie z jej serwera SMTP. 

Połączenie z serwerem SMTP Google jest nawiązywane przy użyciu modułu \texttt{smtplib} na początku działania programu \texttt{nadzor.py}: 
\begin{lstlisting} [language=Python]
def init_smtp(sender, password):
    smtp_server = smtplib.SMTP_SSL("smtp.gmail.com", 465)
    smtp_server.login(sender, password)
    return smtp_server 
\end{lstlisting}
Wymogiem usługi Gmail jest stosowanie szyfrowanego połączenia SSL, które jest nawiązywane przez funkcję \texttt{SMTP{\_}SSL}. Komunikacja odbywa się na standardowym dla tego połączenia porcie TCP 465. Następnie dokonuje się uwierzytelnienie użytkownika na serwerze poprzez przesłanie adresu email konta, z którego mają być wysyłane wiadomości, oraz hasła do niego. Funkcja zwraca referencję obiektu reprezentującego połączenie z serwerem SMTP.

W przypadku, gdy zostanie otwarty czujnik stykowy, oprócz wykonania zdjęcia, sprawdzany jest stan znacznika powiadomień e-mail. Jeśli jest on równy "on", a adres e-mail odbiorcy powiadomień nie jest pusty, rozpoczyna się procedura wysłania powiadomienia. Przygotowany jest tekst wiadomości zawierający informację o otwarciu czujnika i przypisanej mu nazwie. Na temat wiadomości składa się informacja o otwarciu czujnika oraz dacie i godzinie otwarcia. Następnie zostaje utworzony nowy wątek, w którym jest wywoływana funkcja \texttt{wyslij{\_}email()}. Argumentami tej funkcji są: adres e-mail odbiorcy, temat wiadomości, jej treść oraz nazwa zdjęcia, która będzie dołączona jako załącznik. Do otwarcia wątku użyta jest pomocnicza funkcja \texttt{run{\_}threaded}. Użycie wątku zapewnia, że funkcja wysyłająca powiadomienie jest wykonywana współbieżnie z pozostałymi funkcjami sprawdzającymi stany czujników.

Do przygotowania wiadomości e-mail jest wykorzystany obiekt klasy \texttt{MIMEMultipart}. Reprezentuje on wieloczęściową wiadomość e-mail zgodną ze standardem MIME (ang. \textit{Multipurpose Internet Mail Extensions}\cite{mime1}\cite{mime2}.  W polach: \texttt{Subject}, \texttt{To} i \texttt{From} zostają wpisane odpowiednio temat, odbiorca i nadawca wiadomości e-mail. Następnie funkcja otwiera plik ze zdjęciem, które zostało wywołane przez otwarcie czujnika i tworzony jest obiekt \texttt{MIMEImage}, który reprezentuje część wiadomości będącej obrazem. Nie jest tu podawany format zdjęcia, ponieważ obiekt sam dokona sprawdzenia typu zdjęcia przy pomocy modułu \texttt{imghdr}\cite{python-mime}. Dzięki temu zmiana formatu zdjęcia np. z JPEG na PNG nie wymaga zmiany tej części kodu. Przed dołączeniem do wiadomości pliku ze zdjęciem konieczne jest również ustawienie nagłówka \texttt{Content-Disposition} z informacją o tym, że jest to załącznik (\textit{attachment}) oraz o jego nazwie. Dzięki temu obraz zostanie dodany jako załącznik do pobrania w kliencie poczty elektronicznej\cite{content-disposition}. Po dołączeniu załączników następuje wysłanie wiadomości e-mail do serwera SMTP.
\newpage

\section{Baza danych}
\subsection{Założenia wstępne}
Relacyjna baza danych składa się relacji (tabel), które są połączone związkami. W takim modelu organizacji bazy danych łatwo przedstawić rzeczywiste obiekty. Tabela składa się z nagłówka i zawartości. Nagłówek to zbiór atrybutów opisujących zawartość składającą się ze zbioru wierszy. Każda tabela posiada klucz główny, który pozwala jednoznacznie zidentyfikować każdy wiersz. Związki między relacjami są realizowane przez obecność w jednej z tabel uczestniczących w związku klucza obcego, który pozwala jednoznacznie zidentyfikować wiersz z drugiej tabeli.

Programistyczny dostęp do baz danych jest możliwy przez programistyczny interfejs silnika bazy danych opartego na transakcjach. Transakcje to zestaw operacji, które powinny być wykonane w całości albo wcale. Dzięki nim możliwe jest zachowanie integralności danych w sytuacji, gdy wiele klientów (programów) zapisuje dane do bazy danych lub odczytuje z niej.

Projekt bazy danych należy rozpocząć od zdefiniowania, jakie obiekty mają być przechowywane w bazie. W projektowanym systemie potrzebne są informacje o czujnikach i kamerach podłączonych do Raspberry Pi oraz pomiarach wykonanych przez nie. Wszystkie urządzenia mają nazwę identyfikującą ich położenie lub przeznaczenie np. "Kamera w kuchni" lub "Czujnik - drzwi wejściowe". Każdy typ urządzenia różni się jednak specyficznymi dla niego informacjami. Czujnik temperatury dodatkowo potrzebuje informacji o numerze kanału multipleksera, do którego jest podłączona, a czujnik stykowy o numerze swojego wyprowadzenia GPIO. Ponadto każdy typ urządzenia wykonuje inny typ pomiaru i odczytu i z tego powodu informacje o urządzeniach będą przechowywane w różnych tabelach -- osobno kamery, czujniki stykowe i czujniki temperatury.

Baza danych powinna przechowywać informację o stanie czujnika zbliżeniowego, wartości zmierzonej temperatury i wilgotności oraz wykonanym zdjęciu. W bazie danych nie muszą być przechowywane pliki ze zdjęciami, może być to unikalny identyfikator zdjęcia, który pozwoli zlokalizować je w pamięci urządzenia. Zdjęcia, pomiary temperatury i odczyty czujnika stykowego będą wykonywane z różną częstotliwością. Użytkownik potrzebuje natomiast powiązania, jaki w danej chwili jest stan czujnika, odczyt temperatury i wilgotności oraz zdjęcie nadzorowanego miejsca. Konieczna jest więc tabela, która będzie zbierała dla każdej grupy urządzeń składającej się z czujnika, czujnika stykowego i kamery informacje o ostatnich wykonanych pomiarach. Wpisy do tej tabeli muszą być wykonywane tak często, jak najczęściej wykonywany pomiar. Pozostałe wielkości będą ostatnio zmierzonymi. Pozwala to na jasne dopasowanie zdjęcia oraz zmierzonej temperatury i wilgotności do odczytu stanu.

\subsection{Projekt bazy danych}

Na podstawie powyższych założeń stworzyłem projekt bazy danych, który jest przedstawiony na rysunku \ref{fig: er}. Przedstawiony schemat bazy danych na poziomie logicznym to zbiór relacji i związków między nimi, które mogą zostać stworzone w systemie zarządzania bazą danych. 

\begin{figure}[h]
\includegraphics[width=\linewidth]{er.png}
\caption{Schemat bazy danych na poziomie logicznym}
\label{fig: er}
\end{figure}

Baza zawiera tabele \texttt{czujniki}, \texttt{kamery} i \texttt{czujniki{\_}temperatury} z informacjami o poszczególnych typach urządzeń dołączonych do systemu. Wszystkie tabele mają podobne pole przechowujące nazwę urządzenia typu VARCHAR(100). Każde urządzenie przechowuje również częstotliwość wywoływania zdjęcia, pomiaru lub odczytu w polu typu FLOAT. Wartości te są wyrażone w sekundach. Ponadto każde urządzenie przechowuje informację pozwalającą zlokalizować je fizycznie w systemie. W przypadku czujników stykowych jest to numer wyprowadzenia GPIO, do którego podłączony jest czujnik. Czujniki temperatury i wilgotności są identyfikowane przez numer kanału multipleksera, do którego są dołączone. Kamery można rozróżnić dzięki polu \texttt{sciezka{\_}urzadzenia} zawierającym ścieżkę pliku wirtualnego węzła urządzenia. Jest to plik, który system Linux używa do identyfikowania dołączonych urządzeń. 

Tabele \texttt{stany}, \texttt{zdjęcia} i \texttt{odczyty} zawierają informacje o realizacjach pomiarów wykonanych przez te urządzenia. Relacja \texttt{stany} odpowiada odczytom stanów czujników stykowych. Każdy wpis w tabeli jest jednym odczytem  stanu jednego czujnika. Odczyt stanu jest przechowywany w polu \texttt{stan} typu SMALLINT, ponieważ jest zaprojektowany do przechowywania tylko wartości 0 albo 1. W tabeli \texttt{odczyty} przechowywane są pomiary temperatury i wilgotności względnej z jednego czujnika temperatury. Są one liczbami zmiennoprzecinkowymi i dlatego są zapisywane w polach typu FLOAT. Jeśli pomiar został wykonany błędnie, zostanie dokonany wpis do tabeli \texttt{odczyty} zawierający wartości NULL w polach \texttt{temperatur} i \texttt{rh}. Wpisy w tabeli \texttt{zdjęcia} zawierają nazwę pliku ze zdjęciem wykonanym przez kamerę. Jeśli jednak zdjęcie nie zostanie wykonane prawidłowo, w polu \texttt{nazwa} zostanie wpisana wartość NULL.

Tabela \texttt{pomiary} przedstawia status części systemu w czasie, zawierając klucze obce aktualnych w danym momencie zdjęć, odczytów i stanów, pochodzących ze zgrupowanych urządzeń. Jedno zdjęcie lub odczyt temperatury i wilgotności może być przypisane do wielu pomiarów, ale do jednego pomiaru jest przypisany tylko jeden stan czujnika stykowego. Wynika to z tego, że w programie \texttt{nadzor.py} wpisy do tabeli \texttt{pomiary} są wykonywane po odczycie stanu. Następuje on domyślnie co 0,1 sekundy, aby wykrywać oddalenie czujników. Data jest przechowywana w polu o typie DATETIME. 
 
Poza wspomnianymi wyżej relacjami istnieje również relacja \texttt{ustawienia}, która nie jest w związku z żadną inną. Jest to tabela przechowująca różne ustawienia systemu, które nie dotyczą bezpośrednio urządzeń. Posiada ona dwie kolumny: \texttt{klucz} i \texttt{wartosc}. Kolumna \texttt{klucz} jest opisem ustawienia, a \texttt{wartosc} przechowuje informację o nim np. adres e-mail, na który mają być wysyłane powiadomienia. 

Ponadto kamera, czujnik temperatury i czujnik stykowy, który ma wywoływać zdjęcie zostały zgrupowane. Każda kamera przechowuje klucze przypisanych do niej czujników. Odpowiada to związkom jeden do jednego między relacjami \texttt{kamery} i \texttt{czujniki} oraz \texttt{kamery} i \texttt{czujniki{\_}temperatury}.

\subsection{Praktyczna realizacja bazy danych}
Baza danych została zaimplementowana przy użyciu systemu zarządzania bazą danych MySQL. Do stworzenia tabel został napisany skrypt w języku Python. Wykorzystuje on moduł \texttt{SQLAlchemy}, który umożliwia działanie na relacjach bazy danych jak na obiektach programistycznych. Takie odwzorowanie nazywa się mapowaniem obiektowo-relacyjnym (ang. \textit{Object-Relational Mapping} ORM). Ułatwia ono wprowadzanie kolejnych zmian do struktury bazy danych, relacji i związków między nimi.

Bazę danych należy stworzyć, wywołując polecenie w panelu zarządzania bazą danych przy użyciu polecenia:
\begin{lstlisting} [language=SQL]
CREATE DATABASE nadzor;
\end{lstlisting}
Plik zawierający program tworzący tabele w bazie danych nosi nazwę \texttt{baza.py}. W pierwszej kolejności należy stworzyć klasę \texttt{Base}, która zapewnia mapowanie do tabel w bazie danych. Proces tworzenia tabel w bazie polega na stworzeniu klasy odpowiadającej każdej tabeli w bazie, która dziedziczy po klasie \texttt{Base}.\cite{sqlalchemy-base}
\begin{lstlisting} [language=Python]
class Pomiary(Base):
    __tablename__ = 'pomiary'
    id_pomiaru = Column(Integer, primary_key=True)
    id_stanu = Column(Integer, ForeignKey('stany.id_stanu', ondelete='CASCADE'), nullable=False)
    id_odczytu = Column(Integer, ForeignKey('odczyty.id_odczytu', ondelete='CASCADE'), nullable=False)
    id_zdjecia = Column(Integer, ForeignKey('zdjecia.id_zdjecia', ondelete='CASCADE'), nullable=False)
    data = Column(DATETIME)
    stany = relationship(Stany)
    odczyt = relationship(Odczyty)
    zdjecia = relationship(Zdjecia)
\end{lstlisting}

Klasa Pomiary posłuży jako przykład tworzenia tabeli w bazie danych. Należy zdefiniować atrybut \texttt{{\_\_}tablename{\_\_}}, który jest unikalną nazwą tabeli. Następnie tworzone są kolumny przez wywołanie konstruktora klasy Column. W konstruktorze należy przekazać argument będący typem danych przechowywanych w kolumnie. Dla kolumny będącej kluczem głównym należy ustawić znacznik \texttt{primary{\_}key} jako \texttt{True}. Do zdefiniowania związku z inną relacją należy podać jako argument obiekt klasy \texttt{ForeignKey} z informacją, która kolumna w danej tabeli służy jako klucz obcy. Następnie należy zdefiniować związek, wywołując funkcję \texttt{relationship()}. Przyjmuje ona jako argument nazwę klasy. Oznacza to, że definicja tej klasy musi być stworzona wcześniej w kodzie programu.

Dla wszystkich użytych czujników i kamer należy również stworzyć rekordy w bazie danych, odpowiadające im. Odpowiada za to program \texttt{insert.py}. Proces tworzenia nowego wpisu w tabeli polega na stworzeniu słownika zawierającego nazwy kolumn i wartości, które mają być im przypisane. Następnie wywoływana jest funkcja \texttt{get{\_}or{\_}create()}, która najpierw sprawdza, czy istnieje rekord w bazie danych o takich wartościach. Jeśli już istnieje, to zwraca go. Jeśli nie istnieje, to tworzy nowy rekord. Dzięki temu do programu można dopisywać kolejne wywołania, tworzące nowe rekordy w bazie danych i uruchamiać program, który nie stworzy duplikatów już istniejących rekordów. Poniżej przedstawiono przykład stworzenia nowego wpisu w tabeli \texttt{kamery} zgodnie z opisaną wyżej procedurą. Argumentami funkcji \texttt{get{\_}or{\_}create()} są:
\begin{itemize}
\item obiekt klasy \texttt{Session}, która zarządza transakcjami z bazą danych\cite{sqlalchemy-session},
\item nazwa klasy odpowiadającej tabeli, dla której ma być stworzony obiekt,
\item słownik argumentów kluczowych poprzedzony operatorem \texttt{**}.
\end{itemize}
\begin{lstlisting} [language=Python]
titanum_1_kwargs = {
    "nazwa_kamery": "Kamera 1 - Titanum",
    "sciezka_urzadzenia": "/dev/video0",
    "id_czujnika": kontaktron_1.id_czujnika,
    "id_czujnika_temp": si7021_zielony.id_czujnika_temp,
    "czestotliwosc_zdjecia": 10.0
}
titanum_1 = get_or_create(session, Kamery, **titanum_1_kwargs)
\end{lstlisting}

W podobny sposób dokonywane są zapisy do tabel \texttt{stany}, \texttt{zdjęcia} i \texttt{odczyty}. Wykonywane są one w programie \texttt{nadzor.py} odpowiednio w funkcjach: \linebreak\texttt{sprawdz{\_}kontaktron()}, \texttt{pomiar{\_}temperatury{\_}rh} i \texttt{zrob{\_}zdjecie}. Przykładowo, wyniki pomiarów temperatury i wilgotności zostają zapisane do słownika przy kluczach odpowiadających nazwom odpowiednich kolumn w tabeli. Pozostałym polem w słowniku jest identyfikator czujnika stykowego, dla którego został wykonany odczyt. Następnie wynik zostaje zapisany do bazy danych poprzez funkcję \texttt{create()}. Jej argumenty są takie same jak opisanej wyżej funkcji \texttt{get{\_}or{\_}create()}. Zwrócony obiekt odpowiadający nowemu wpisowi w bazie danych jest zapisywany w odpowiednim polu klasy Grupa.
\begin{lstlisting} [language=Python]
odczyt = {
	"id_czujnika_temp": self.czujnik_temp.id_czujnika_temp,
	"temperatura": temp,
	"rh": rh
}
self.odczyt_instance = create(self.session, Odczyty, **odczyt)
\end{lstlisting}

Odczyt czujników stykowych jest najczęściej wykonywanym pomiarem, więc po stworzeniu nowego wpisu w tabeli \texttt{stany} powinien zostać stworzony wpis do tabeli pomiary. Zostaje do niej wpisany rekord zawierający identyfikator właśnie wykonanego odczytu stanu oraz identyfikatory ostatnich wykonanych zdjęć oraz pomiarów temperatury odczytane z pól obiektu klasy Grupa. Wraz z nimi zostaje zapisana data wpisu odczytana przy pomocy funkcji \texttt{datetime.now()} zapisana w formacie \textit{dzień-miesiąc-rok godzina-minuta-sekunda.mikrosekunda}.
\begin{lstlisting}
pomiar = {
	"id_stanu": stan_instance.id_stanu,
	"id_odczytu": self.odczyt_instance.id_odczytu,
	"id_zdjecia": self.zdjecie_instance.id_zdjecia,
	"data": data
}
pomiar_instance = create(self.session, Pomiary, **pomiar)
\end{lstlisting}

\newpage

\section{Strona i serwer WWW}

\subsection{Serwer WWW}
Wymogiem systemu jest umożliwienie użytkownikowi dostępu do zebranych danych przez stronę WWW. Konieczny jest zatem serwer HTTP, na którym będzie umieszczona strona. Jednym z najpopularniejszych środowisk do prowadzenia serwerów WWW jest Apache. Jest on dostępny w wersji dla systemu Raspbian, który działa na Raspberry Pi. Umieszczona na serwerze strona będzie komunikowała się z serwerem poprzez żądania HTTP. Szkielet strony w postaci pliku HTML będzie wypełniony danymi zebranymi przez kamery i czujniki po zrealizowaniu żądań wysyłanych asynchronicznie (przy użyciu techniki AJAX) do serwera. Za obsługę żądań po stronie serwerowej będą odpowiedzialne mikrousługi w postaci skryptów w języku PHP. Skrypty łączą się z bazą danych, w której są przechowywane dane zebrane z kamer i czujników. Następnie zwracają dane w odpowiedzi na żądania klienta. Język PHP został wybrany do obsługi żądań po stronie serwerowej, ponieważ jest dobrze zintegrowany z serwerem Apache i jest jedną z najbardziej popularnych technologii na serwerach WWW.

Dostęp do danych prezentowanych w interfejsie powinien być zabezpieczony. Autoryzacja użytkownika na stronie została wykonana w formie uwierzytelnienia prostego (ang. \textit{basic authentication}). Wymaga ono jedynie stworzenia na serwerze pliku z hasłem przy użyciu narzędzia \texttt{htpasswd} będącego częścią pakietu Apache. Plik z hasłem jest przechowywany poza folderem, w którym są przechowywane pliki strony internetowej, dzięki czemu jest poza zasięgiem ewentualnego ataku. Hasło przechowywane jest w formie 128-bitowego skrótu (ang. \textit{hash}) stworzonego przy pomocy funkcji skrótu MD5.\cite{apache-password} Dzięki temu hasło nie jest przechowywane w formie prostego tekstu, który mogłyby od razu odczytany w wypadku zdobycia dostępu do komputera Raspberry Pi przez niepożądaną osobę. Z przesłanego przez użytkownika hasła również tworzony jest skrót, który jest porównywany ze skrótem hasła przechowywanym w pliku. Jeśli skróty są równe, oznacza to, że przesłane hasło jest poprawne. Komunikacja między serwerem a klientem odbywa się w formie nieszyfrowanej HTTP, przez co klient wysyła swoje hasło i login niezaszyfrowane w nagłówku żądania HTTP.\cite{http-auth} Tym samym osoba podsłuchująca komunikację mogłaby poznać dane logowania. Jest to słabość zabezpieczeń systemu w obecnej postaci, którą należałoby w przyszłości wyeliminować, używając szyfrowania SSL w komunikacji przy użyciu protokołu HTTP. Dodatkowym usprawnieniem byłoby użycie funkcji skrótu z rodziny SHA-2 lub SHA-3 do wygenerowania skrótów haseł przechowywanych na serwerze. Są one w tej chwili uważane za niemożliwe do złamania.
 
\subsection{Żądania HTTP i ich obsługa -- technika AJAX}
Po pozytywnym uwierzytelnieniu użytkownika w systemie udostępniony jest plik \texttt{index.html} Zawiera on szkielet strony oraz dołączone skrypty JavaScript w tym skrypt \texttt{main.js}, który zawiera funkcje realizujące żądania HTTP. Służą one do pobierania danych z systemu oraz wprowadzania ustawień dokonanych przez użytkownika. Wykorzystania została do tego technika AJAX (ang. \textit{Asynchronous JavaScript and XML}). Jest to technika tworzenia aplikacji internetowych, w której żądania są wykonywane asynchronicznie. Technika ta jest oparta o architekturę serwer-klient, w której rolę klienta pełni przeglądarka. Po wysłaniu żądania przeglądarka kontynuuje działanie, a po odebraniu danych przetwarza je. Dzięki temu dane mogą być odświeżane na stronie bez konieczności jej przeładowania. To bardzo przydatna cecha, która pozwala odświeżać dane w tle tak, że użytkownik zawsze obserwuje aktualny stan systemu.

Do przygotowania żądań wykorzystywana jest funkcja \texttt{\$.ajax()} z biblioteki jQuery. Przygotowuje ona obiekt \texttt{XMLHTTPRequest}, który reprezentuje żądanie HTTP. Funkcja pozwala określić adres URL, do którego ma być skierowane żądanie, typ żądania (GET, POST, DELETE itp.), dołączone dane oraz pozostałe pola odpowiadające nagłówkom protokołu HTTP. Żądania te będą kierowane do dedykowanych programów w języku PHP działających na serwerze WWW. Wykonują one zapytania do bazy danych i zwracają ich wyniki lub dokonują wpisów do niej. Działanie poszczególnych skryptów zostanie omówione w poniższych podrozdziałach.

\subsubsection{Strona główna i archiwum}
Podstawowym żądaniem wywoływanym przez funkcję \texttt{main.js} jest żądanie pobrania aktualnego stanu systemu. Jest ono wywoływane w funkcji \texttt{main()} przez funkcję \texttt{getData()}:
\begin{lstlisting} [language=JavaScript]
function getData() {
    return $.ajax({
        url: "get_data.php?q=",
        type: "GET",
        contentType: "text/plain"
    })
}
\end{lstlisting}
Funkcja przygotowuje żądanie typu GET do mikrousługi \texttt{get{\_}data.php} z pustym parametrem \texttt{q}. Informuje on o tym, że mają być przesłane tylko dane o aktualnym stanie systemu. Funkcja zwraca obiekt typu \texttt{Promise} (ang.\textit{obietnica}), który reprezentuje ostateczne zakończenie lub niepowodzenie operacji asynchronicznej.\cite{promise} 

Po otrzymaniu żądania program \texttt{get{\_}data.php} odczytuje ze zmiennej \texttt{{\$\_}GET} wartość parametru \texttt{q}. Posłuży on do określenia, jakie zapytania maja być wysłane do bazy danych. Następnie nawiązywane jest połączenie z bazą danych przy pomocy biblioteki PDO:
\begin{lstlisting} [language=PHP]
$conn = new PDO("mysql:host=$servername;dbname=$db", $username, $password);
\end{lstlisting}
Zmienna \texttt{\$conn} reprezentująca połączenie z bazą danych jest użyta do wykonania zapytania o wszystkie wpisy z tabeli \texttt{kamery}. Jeśli parametr \texttt{q} jest pusty, to dla każdej kamery jest wykonywane zapytanie do tabeli \texttt{pomiary} o zbiór ostatnich wykonanych pomiarów:
\begin{lstlisting} [language=PHP]
$stmt = $conn->query("
SELECT *
FROM pomiary NATURAL JOIN zdjecia NATURAL JOIN stany NATURAL JOIN odczyty
WHERE zdjecia.id_kamery = $id_kamery 
GROUP BY pomiary.id_pomiaru 
ORDER BY pomiary.id_pomiaru DESC LIMIT 1
");
\end{lstlisting}
Wynik tego zapytania jest zapisywany w tablicy pod indeksem równym unikalnemu identyfikatorowi kamery. Po dokonaniu zapytań dla wszystkich kamer istniejących w systemie, program zwraca odpowiedź w formie JSON (ang. \textit{JavaScript Object Notation}). Jest to jeden z powszechnie stosowanych formatów tekstowej wymiany danych. W nagłówku odpowiedzi należy przekazać informację o typie MIME przekazywanych danych\cite{mime2} -- \texttt{Content-Type: application/json}. Następnie dane są zakodowane do postaci JSON przy użyciu funkcji \texttt{json{\_}encode} i zwrócone przy pomocy funkcji \texttt{echo}.

Zwrócone dane można obsłużyć po stronie klienta (przeglądarki) na kilka sposobów. Jednym z najnowszych sposobów dostępnych w wersji języka JavaScript ECMAScript 2017 jest składnia \texttt{async/await}. Jest ona obsługiwana przez większość współczesnych przeglądarek w najnowszej wersji.\cite{async} Pozwala ona na wykonywanie asynchronicznego kodu w sposób przypominający tradycyjne, sekwencyjne działanie. Zaletą takiego rozwiązania jest poprawienie czytelności kodu. 

Definicja funkcji działającej w sposób asynchroniczny musi być poprzedzona słowem kluczowym \texttt{async}. W ciele funkcji można wówczas wywoływać funkcje zwracające obiekty Promise ze słowem kluczowym \texttt{await}. Powoduje to wstrzymanie działania funkcji do momentu rozwiązania obietnicy:
\begin{lstlisting} [language=JavaScript]
async function main() {
    try {
        const result = await getData();
        displayHomeContent(result);
        (...)
    } catch (e) {
        console.log(e.responseText);
        (...)
    }
	(...)
}
\end{lstlisting}
Funkcja \texttt{getData()} jest wywoływana w bloku \texttt{try/catch} pozwalającym na obsługę wyjątków w przypadku niepowodzenia asynchronicznego żądania HTTP. W przypadku pozytywnego zakończenia żądania dane zwrócone w odpowiedzi są zapisywane do zmiennej i mogą być użyte przez funkcję \texttt{displayHomeContent()} wyświetlającą dane na stronie głównej.

Procedura pobierania danych o archiwalnych stanach systemu jest podobna. Przesłanie żądania do serwera wykonuje funkcja \texttt{getAllData()}. Wywołuje ona żądanie typu GET do mikrousługi \texttt{get{\_}data.php} z atrybutem \texttt{q} równym \texttt{archiwum}. Po stronie serwerowej żądanie obsługiwane jest podobnie do żądania z pustym atrybutem \texttt{q}. Różnica polega na tym, że dla każdej kamery w systemie zwracana jest cała historia jej zdjęć przy użyciu poniższego zapytania do bazy danych:
\begin{lstlisting} [language=PHP]
$stmt = $conn->query("
SELECT *
FROM zdjecia NATURAL JOIN pomiary NATURAL JOIN stany NATURAL JOIN odczyty
WHERE zdjecia.id_kamery = $id_kamery
");
\end{lstlisting}
Następnie dane są zapisywane w formie JSON i zwracane do klienta przez funkcję \texttt{echo}. Po stronie przeglądarki obiekt \texttt{Promise} zwracany przez funkcję \texttt{getAllData()} również jest obsługiwany przy pomocy składni \texttt{await/async}. Po pozytywnym zakończeniu pobierania danych, tworzony jest widok archiwum.

\subsubsection{Ustawienia}
Przez stronę WWW użytkownik ma również dostęp do panelu administracyjnego pozwalającego na zmianę ustawień. Dostępne ustawienia to:
\begin{itemize}
\item włączenie powiadomień e-mail i podanie adresu e-mail odbiorcy powiadomień,
\item zmiana nazwy urządzeń podłączonych do systemu,
\item zmiana częstotliwości wykonywania zdjęć i pomiarów.
\end{itemize}

Po dokonaniu zmian w formularzu i zapisaniu zmian skrypt \texttt{main.js} zapisuje dane ze wszystkich elementów typu \texttt{form}. Wykorzystywana jest przy tym funkcja \texttt{serializeArray()} z biblioteki jQuery. Zapisuje ona dane z formularza do tablicy obiektów o postaci: \texttt{\{name: <Nazwa ustawienia>, value: <Wartość ustawienia>\}}. W przypadku formularzy z danymi dotyczącymi ustawień nazw urządzeń i częstotliwości pomiarów obiekty te zostaną przekształcone do postaci: \texttt{\{<Nazwa ustawienia>: <Wartość ustawienia>\}}. Jest ona łatwiejsza do parsowania po stronie serwerowej, ponieważ od razu łączy nazwę kolumny z wartością, która ma być dla niej ustawiona. Wykorzystana do tego zostanie wbudowana funkcja obiektu \texttt{Array} -- \texttt{reduce()}:
\begin{lstlisting}[language=JavaScript]
const data = $(element).serializeArray().reduce((a, x) => {
	a[x.name] = x.value;
	return a;
}, {});
\end{lstlisting}
Pierwszym argumentem funkcji \texttt{reduce()} jest anonimowa funkcja wywołana przy pomocy wyrażenia funkcji strzałkowej (\texttt{=>}), która jest wywołana dla każdego elementu tablicy. Wykorzystuje ona dwa argumenty: tablicę, która ma być spłaszczona oraz aktualną jej wartość. Wartość ustawienia jest zapisywana przy kluczu ją opisującym, a wynik zapisywany jest w nowym obiekcie podanym jako drugi argument funkcji -- \texttt{\{\}}. W ten sposób dane są zapisane w formie JSON, a następnie zamienione w ciąg znaków (\texttt{string}).

Każde z wymienionych wyżej ustawień posiada osobną funkcję przygotowującą żądanie typu POST do serwera. Jest to typ żądania HTTP używany do przesyłania danych z formularzy.\cite{http} Wynika to z tego, że każde z tych danych jest inaczej przetwarzane po stronie serwera. Dla ustawień e-mail jest to funkcja \texttt{updateSettings()}. Wysyła ona żądanie typu POST do mikrousługi \texttt{update{\_}settings.php}. Program ten zaczyna od zdekodowania przesłanych danych w formie JSON do tablicy:
\begin{lstlisting}[language=PHP]
$input = json_decode(file_get_contents('php://input'))
\end{lstlisting}
Następnie dla każdego ustawienia (pary klucz/wartość) wykonywane jest zapytanie typu UPDATE do bazy danych o następującej treści:
\begin{lstlisting}[language=SQL]
UPDATE ustawienia 
SET wartosc=:wartosc
WHERE klucz=:klucz
\end{lstlisting}
, gdzie \texttt{:wartosc} oraz \texttt{:klucz} zostaną uzupełnione odpowiednimi danymi w momencie wykonywania zapytania przez funkcję \texttt{execute()}. Użycie parametryzowanych zapytań zabezpiecza system przed atakami typu \textit{SQL Injection}. Polegają one na umieszczeniu np. w treści formularza innego zapytania języka SQL, które umieszczone bezpośrednio w treści zapytania mogłoby narazić bazę danych np. na usunięcie którejś z tabel.\cite{sql-injection}

Informacje o zmianie nazw urządzeń są przesyłane w postaci żądania HTTP typu POST przez funkcję \texttt{updateNames()} do mikrousługi \texttt{update{\_}names.php}. Dla każdej kamery i przypisanych do niej czujników jest wysyłane osobne żądanie zawierające wprowadzone nazwy oraz identyfikator kamery. Program \texttt{update{\_}names.php} po zdekodowaniu przesłanych danych wykonuje zapytanie do bazy danych o identyfikatory czujników, które są przypisane do kamery o przesłanym identyfikatorze. Następnie dla każdego urządzenia następuje aktualizacja nazw, jeśli przesłany ciąg znaków nie jest pusty. W tym przypadku również użyto parametryzowanych zapytań.

Zmiana preferencji wykonywania pomiarów i zdjęć jest przekazywana do serwera przy użyciu funkcji \texttt{updatePrefs()}. Przekazuje ona zebrane z formularza dane do mikrousługi \texttt{update{\_}prefs.php}, załączając je do żądania typu POST. Dane te również są wysyłane osobno dla każdej grupy urządzeń z identyfikowanych kluczem głównym obiektu typu kamera. W tym wypadku dane są zmieniane w zbiorczym zapytaniu do bazy danych:
\begin{lstlisting}[language=SQL]
UPDATE 
kamery NATURAL JOIN czujniki NATURAL JOIN czujniki_temperatury 
SET 
kamery.czestotliwosc_zdjecia = :czestotliwosc_zdjecia, 
czujniki.czestotliwosc_odczytu_stanu = :czestotliwosc_odczytu_stanu,
czujniki_temperatury.czestotliwosc_pomiaru_temp = :czestotliwosc_pomiaru_temp
WHERE 
id_kamery = :id_kamery
\end{lstlisting}

\subsubsection{Eksport zdarzeń}
Wymagania systemu mówią również o możliwości eksportu listy zdarzeń -- stanów systemu do pliku w formacie \texttt{csv}. Wysłanie żądania pobrania pliku jest realizowanie inaczej niż w opisanej wyżej technice AJAX. Zostaje otwarte nowe okno przeglądarki, którego adres URL jest ustawiony jako \texttt{export{\_}events.php?start=<Data początku>{\&}end=<Data końca>}. Użytkownik może wybrać w interfejsie przedział dat, dla których mają być wyeksportowane zdarzenia. Są one umieszczane jako wartości parametrów \texttt{start} i \texttt{end}. Okno to jest puste i służy jedynie do wymuszenia otwarcia okna dialogowego do zapisu pliku, o który prosi użytkownik.

Otwarcie nowego okna w przeglądarce z adresem URL programu \texttt{export{\_}events.php} powoduje wywołanie jego działania po stronie serwerowej. Program pobiera wartości parametrów \texttt{start} i \texttt{end}, a następnie wykonuje zapytanie do bazy danych o pierwszy i ostatni rekord z tabeli \texttt{pomiary}. Jeśli użytkownik nie wybrał daty początku lub końca zakresu, dla którego mają być eksportowane zdarzenia, zostaną one domyślnie ustawione odpowiednio jako data pierwszego lub ostatniego wpisu w bazie danych. Takie podejście pozwala na eksport wszystkich zdarzeń poprzez pozostawienie wartości parametrów \texttt{start} i \texttt{end} pustych.

Następnie wykonywane jest zapytanie do bazy danych o wszystkie wpisy do tabeli \texttt{pomiary} wraz z odpowiadającym im odczytom urządzeń i informacjami o urządzeniach:
\begin{lstlisting}[language=SQL]
SELECT *
FROM pomiary 
NATURAL JOIN zdjecia NATURAL JOIN kamery
NATURAL JOIN stany NATURAL JOIN czujniki
NATURAL JOIN odczyty NATURAL JOIN czujniki_temperatury
WHERE data BETWEEN :first_date AND :last_date
\end{lstlisting}
Dane zwrócone przez zapytanie są zapisywane do pliku w formacie \texttt{csv} o nazwie informującej o wybranym przedziale dat. W pliku wynikowym zapisywane są również nagłówki kolumn, dzięki czemu użytkownik otrzyma informację o tym, co przedstawiają dane. Po zakończeniu zapisu do pliku, jego zawartość jest zwrócona użytkownikowi przy pomocy funkcji \texttt{readfile}. Sam plik jest przechowywane na serwerze w folderze \texttt{log}. Dzięki temu kolejne zapytania o zdarzenie z tego samego zakresu dat nie wymagają przeprowadzenia zapytania do bazy danych. Przed przeprowadzeniem zapytania program sprawdza, czy istnieje już plik o nazwie odpowiadającej żądanemu przedziałowi dat. Jeśli tak, plik zostaje odczytany i zwrócony do klienta.

Aby zwrócone dane były potraktowane jako plik do zapisu jako załącznik, konieczne jest właściwe ustawienie nagłówków odpowiedzi:
\begin{lstlisting}[language=PHP]
header("Content-Description: File Transfer");
header("Content-Type: application/octet-stream");
header('Content-Disposition: attachment; filename="'.basename($file).'"');
\end{lstlisting}
Odpowiadają one za przekazanie informacji klientowi, że następuje transfer pliku (\texttt{File Transfer}) typu binarnego (\texttt{application/octet-stream}), który ma zostać zapisany po otwarciu okna dialogowego do zapisu plików (\texttt{Content-Disposition: attachment}).\cite{content-disposition}\cite{mime2}

\subsection{Interfejs użytkownika}
Interfejs użytkownika stanowi strona WWW typu \textit{single-page application}(SPA), której szkielet jest opisany w pliku \texttt{index.html}. Idea SPA polega na stworzeniu strony WWW, która nie wymaga przeładowywania, żeby prezentować różną zawartość, a wszystkie dane mogą być udostępniane przez jeden plik HTML. Odświeżanie zawartości strony następuje w tle dzięki komunikacji z serwerem WWW. W projektowanym systemie komunikacja ta została wykonana zgodnie z techniką AJAX opisaną powyżej. Do wykonania interfejsu użytkownika posłużyłem się biblioteką \textit{UIKit}, która dostarcza gotowe rozwiązania takich elementów jak np. okna modalne czy elementy nawigacyjne.

Na stronie głównej przedstawionej na rysunku \ref{fig: homepage} domyślnie wyświetlane są ostatnie zdjęcia ze wszystkich kamer w systemie. Na karcie kamery znajdują się: nazwa kamery, ostatnie zdjęcie nią wykonane oraz dane z czujnika temperatury i czujnika stykowego przypisanego do kamery. Dane te są odświeżane domyślnie co 8 sekund (częściej niż wykonywane zdjęcia), aby stale prezentować użytkownikowi aktualny stan systemu. 
\begin{figure}[H]
\begin{center}
\includegraphics[width=\linewidth]{ekran_glowny.png}
\caption{Strona główna interfejsu użytkownika}
\label{fig: homepage}
\end{center}
\end{figure}
Pasek nawigacyjny u góry ekranu pozwala przejść do \textit{Archiwum} prezentującego przeszłe zdjęcia podzielone według kamer, które je wykonały. Zdjęcia są przedstawiane w postaci miniatur umieszczonych na siatce. Po kliknięciu na nie zdjęcie powiększa się, zajmując cały ekran. Wówczas zdjęcia można również przeglądać w trybie galerii zdjęć.

Wybór linku \textit{Zapisz} otwiera okno modalne z dwoma polami do wyboru dat. Na rysunku \ref{fig: eksport} widać stan okna w przypadku wybrania początkowej daty. Wówczas w drugim kalendarzu do wyboru dat dostępny jest wyłącznie zakres dat następujący po wybranej dacie początku. Implementację kalendarza do wyboru dat dostarcza biblioteka \textit{Pikaday}. W momencie tworzenia obiektu można podać nazwę funkcji, która ma być wykonywana w momencie wyboru daty (zdarzenie \texttt{OnSelect}). W przypadku kalendarza do wyboru początkowej daty jest to funkcja \texttt{updateStartDate}, a dla kalendarza do wyboru końcowej daty \texttt{updateEndDate}:
\begin{lstlisting}[language=JavaScript]
function updateStartDate(startDate, startPicker, endPicker) {
    startPicker.setStartRange(startDate);
    endPicker.setStartRange(startDate);
    endPicker.setMinDate(startDate);
}

function updateEndDate(endDate, startPicker, endPicker) {
    startPicker.setEndRange(endDate);
    startPicker.setMaxDate(endDate);
    endPicker.setEndRange(endDate);
}
\end{lstlisting}
Pierwsza z nich odpowiada za ustawienie wybranej daty początkowej jako najmniejszej możliwej w kalendarzu do wyboru daty końcowej. Druga wykonuje analogiczną operację z wybraną datą końcową i kalendarzem do wyboru daty początkowej. Dzięki temu interfejs nie pozwala na wprowadzenie błędnych zakresów dat np. takich, w których data początku jest większa niż data końca.
\begin{figure}[H]
\begin{center}
\includegraphics[width=\linewidth]{eksport_zdarzen.png}
\caption{Okno modalne do eksportu listy zdarzeń}
\label{fig: eksport}
\end{center}
\end{figure}

Otworzenie okna modalnego z panelem administracyjnym jest możliwe po kliknięciu w link \textit{Ustawienia}. Okno ustawień składa się z kilku formularzy umożliwiających ich zmianę. Sekcja \textit{Ogólne} pozwala na włączenie powiadomień e-mail. Po zaznaczeniu pola wyboru (ang. \textit{checkbox}) tego ustawienia pojawia się również pole tekstowe, w którym można wpisać adres e-mail odbiorcy powiadomień. Kolejna sekcja \textit{Zmień nazwę} składa się z pól tekstowych opisanych dotychczasowymi nazwami urządzeń. Nazwa nie jest zmieniana, jeśli pole jest pozostawione puste. Ostatnia sekcja \textit{Preferencje} umożliwia zmianę częstotliwości wykonywania zdjęć i pomiarów. Pola tekstowe opisane nazwa urządzeń są domyślnie wypełnione dotychczasowymi wartościami. Wszystkie zmiany są wprowadzane dopiero po zatwierdzeniu ich przyciskiem \textit{Zapisz}.

\newpage
\section{Testy systemu}

\newpage
\section{Wnioski i podsumowanie}

\newpage
\section{Bibliografia}
\begin{thebibliography}{9}

\bibitem{apache-auth}
Apache Software Foundation, Authentication and Authorization, Dokumentacja serwera HTTP Apache
\url{https://httpd.apache.org/docs/2.4/howto/auth.html}

\bibitem{apache-password}
Apache Software Foundation, htpasswd - Manage user files for basic authentication, Dokumentacja serwera HTTP Apache
\url{https://httpd.apache.org/docs/2.4/programs/htpasswd.html}

\bibitem{zachorowania}
Arundel A. V., Sterling E. M., Biggin J. H. i Sterling T. D., Indirect health effects of relative humidity in indoor environments, \textit{Environmental Health Perspectives} 1986;65:351-361
\url{https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1474709/}

\bibitem{sqlalchemy-session}
Bayer M., Session Basics, Dokumentacja SQLAlchemy
\url{http://docs.sqlalchemy.org/en/latest/orm/session_basics.html}

\bibitem{sqlalchemy-base}
Bayer M., Declarative API, Dokumentacja SQLAlchemy
\url{http://docs.sqlalchemy.org/en/latest/orm/extensions/declarative/api.html}

\bibitem{bb_black}
BeagleBoard.org Foundation, Specyfikacja BeagleBone Black
\url{https://elinux.org/Beagleboard:BeagleBoneBlack}

\bibitem{sql-injection}
Clarke J., SQL Injection Attacks and Defense, wyd. 2, Syngress, 2012, ISBN 978-1-59749-963-7  

\bibitem{komputer_świat}
Dziedzic K., Kamera IP w sieci. Stwórz prywatny monitoring
\url{http://www.komputerswiat.pl/poradniki/sprzet/kamery-internetowe/2015/07/kamera-ip-w-sieci.aspx}

\bibitem{http}
Fielding R., Reschke J., Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content, RFC7231, IETF, czerwiec 2014, DOI: 10.17487/RFC7231
\url{https://tools.ietf.org/html/rfc7231}

\bibitem{http-auth}
Fielding R., Reschke J., Hypertext Transfer Protocol (HTTP/1.1): Authentication, RFC 7235, IETF, czerwiec 2014, DOI: 10.17487/RFC7235.
\url{https://tools.ietf.org/html/rfc7235}

\bibitem{mime1}
Freed N., Borenstein N., Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies, RFC 2045, IETF, listopad 1996, DOI: 10.17487/RFC2045.
\url{https://tools.ietf.org/html/rfc2045}

\bibitem{mime2}
Freed N., Borenstein N., Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types, RFC 2046, IETF, listopad 1996, DOI: 10.17487/RFC2046.
\url{https://tools.ietf.org/html/rfc2046}

\bibitem{th02}
Hoperf Electronic, Karta katalogowa czujnika temperatury i wilgotności TH02:
\url{http://www.hoperf.com/upload/sensor/TH02_V1.1.pdf}

\bibitem{i2c_read_device}
joan2937, Dokumentacja funkcji \texttt{i2c{\_}read{\_}device()}
\url{http://abyz.me.uk/rpi/pigpio/python.html#i2c_read_device}

\bibitem{sht31}
Mouser Electronics, Karta katalogowa czujnika temperatury i wilgotności SHT31D:
\url{http://www.mouser.com/ds/2/682/Sensirion_Humidity_Sensors_SHT3x_Datasheet_digital-971521.pdf}

\bibitem{promise}
Mozilla Developer Network, szopenkrk, Promise.
\url{https://developer.mozilla.org/pl/docs/Web/JavaScript/Referencje/Obiekty/Promise}

\bibitem{async}
Mozilla Developer Network, Bab64, doubleOrt, freezy, hirokiky, jswisher, spygi i in., async function.
\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function}

\bibitem{porownanie_wiki}
Porównanie komputerów jednopłytkowych (ang.)
\url{https://en.wikipedia.org/wiki/Comparison_of_single-board_computers}

\bibitem{python-mime}
Python Software Foundation, Dokumentacja modułu Python email.mime
\url{https://docs.python.org/3/library/email.mime.html}

\bibitem{rpi_schematic}
Raspberry Pi Foundation, Schematy peryferiów Raspberry Pi 3 Model B
\url{https://www.raspberrypi.org/documentation/hardware/raspberrypi/schematics/rpi_SCH_3b_1p2_reduced.pdf}

\bibitem{rpi}
Raspberry Pi Foundation, Specyfikacja Raspberry Pi 3 Model B
\url{https://www.raspberrypi.org/products/raspberry-pi-3-model-b/}

\bibitem{content-disposition}
Reschke J. Use of the Content-Disposition Header Field in the Hypertext Transfer Protocol (HTTP), RFC 6266, IETF, czerwiec 2011, DOI: 10.17487/RFC6266.
\url{https://tools.ietf.org/html/rfc6266}

\bibitem{czujnik_temp}
Silicon Labs, Karta katalogowa czujnika temperatury i wilgotności Si7021:
\url{https://www.silabs.com/documents/public/data-sheets/Si7021-A20.pdf}

\bibitem{multiplekser}
Texas Instruments Inc., Karta katalogowa multipleksera TCA9548A:
\url{http://www.ti.com/lit/ds/symlink/tca9548a.pdf}

\bibitem{smbus}
Torvalds L., Opis protokołu SMBus
\url{https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/plain/Documentation/i2c/smbus-protocol}

\end{thebibliography}

\newpage
\section{Załączniki}


\end{document}
