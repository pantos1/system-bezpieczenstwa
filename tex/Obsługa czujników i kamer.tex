\documentclass[a4paper,12pt,twoside]{article}
\renewcommand{\familydefault}{\sfdefault}
\addtolength{\hoffset}{-1.54cm}
\setlength{\oddsidemargin}{2cm}
\setlength{\textwidth}{16cm}

\addtolength{\voffset}{-1in}
\setlength{\topmargin}{1.5cm}
\setlength{\headheight}{5mm}
\setlength{\headsep}{5mm}
\setlength{\textheight}{247mm}
\setlength{\footskip}{1cm}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{polski}
\usepackage{listings}
\usepackage{graphicx} 
\usepackage{color}
\usepackage{helvet}
\usepackage{courier}
\usepackage{pdfpages}
\usepackage{multirow}
\usepackage{hyperref}
\usepackage{float}
\renewcommand*{\tablename}{Tabela}

\usepackage{fancyhdr}
\fancypagestyle{plain}{
\fancyhead{}
\cfoot{}
\fancyfoot[LE, RO]{\thepage}}
\renewcommand{\headrulewidth}{0pt}

\pagestyle{plain}

\usepackage{tocloft}
\makeatletter
\renewcommand*\@seccntformat[1]{\csname the#1\endcsname.\enspace}
\makeatother
\renewcommand{\cftsecaftersnum}{.}
\renewcommand{\cftsubsecaftersnum}{.}
\renewcommand{\cftsubsubsecaftersnum}{.}
\renewcommand{\cftparaaftersnum}{.}
\renewcommand{\cftsubparaaftersnum}{.}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ 
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}; should come as last argument
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  %frame=single,	                   % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  morekeywords={*,...},            % if you want to add more keywords to the set
  numbers=none,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,	                   % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}

\begin{document}
\section{Program procedury obsługi kamer i czujników}
Program nadzor.py obsługujący czujniki i kamery musi cyklicznie wykonywać pomiary, odczyty i zdjęcia, a wyniki zapisywać do bazy danych. Potrzebne jest narzędzie, które pozwoli okresowo wykonywać funkcje w ramach jednego programu. Istnieją mechanizmy wewnątrz języka Python(moduł \texttt{sched}), które umożliwiają wykonywanie zadań po minięciu pewnego czasu lub zaplanowanie ich do wykonania o konkretnej porze. Wykorzystanie tego modułu wymagałoby jednak ponownego zaplanowania zadania po każdym jego wykonaniu. Modułem, który umożliwia dokonanie tego w prostszy sposób, jest biblioteka \texttt{schedule}. Jest ona przeznaczona do planowania cyklicznego wykonywania zadań. Przykładowe wywołanie szeregowania przy użyciu \texttt{schedule} przedstawiono poniżej.
\begin{lstlisting} [language=Python]
schedule.every(kamera.czestotliwosc_zdjecia).seconds.do(grupa.zrob_zdjecie)
\end{lstlisting}
Jako argument \texttt{every()} podawana jest częstotliwość wykonywania zadania, następnie podawane są jednostki oraz nazwa funkcji jako argument \texttt{do()}.

\begin{figure}[H]
\begin{center}
\includegraphics[width=0.5\linewidth]{Grupa.png}
\caption{Diagram UML klasy Grupa}
\label{fig: Grupa}
\end{center}
\end{figure}

Rysunek \ref{fig: Grupa} przedstawia diagram UML klasy Grupa. Skrótem \textit{m} oznaczone są metody klasy, a \textit{f} - atrybuty. Działanie poszczególnych metod jest opisane w poniższych podrozdziałach. 

Program jest napisany przy użyciu metodyki obiektowej. Takie podejście pozwala powiązać czujnik z kamerą, która będzie wykonywała zdjęcia w przypadku jego otwarcia. Klasa Grupa reprezentuje te dwa urządzenia oraz dodatkowo przypisany do nich czujnik temperatury. Zawiera ona metody, które wykonujące zdjęcie, pomiar temperatury i wilgotności oraz odczyt stanu wyprowadzenia GPIO, do którego jest podłączony czujnik stykowy. Zarządza ona również wysłaniem wiadomości email z powiadomieniem w przypadku otwarcia czujnika.

\subsection{Obsługa kamer USB}
Kamery USB są obsługiwane przez metodę \texttt{wyslij{\_}email}. Do samego wykonywania zdjęć użyta jest aplikacja \texttt{fswebcam}. Jest to samodzielny program pozwalający na wywoływanie zdjęć z kamer USB podłączonych do komputera z systemem typu Unix. Program ten pozwala na wywołanie zdjęcia z określonej kamery, zdefiniowane rozdzielczości zdjęcia, umieszczenie na zdjęciu podpisu z datą i godziną wykonania zdjęcia. 

Wywołanie \texttt{fswebcam} z poziomu programu w języku Python wymaga użycia modułu \texttt{subprocessing}. Daje on możliwość otwierania programów w osobnych procesach. W tym przypadku użyta została klasa \texttt{Popen} z tego modułu otwierająca nowy podproces. Klasa jest dostępna zarówno w wersji języka Python 2 jak i 3. Tworząc obiekt klasy, należy przekazać do niego listę składającą się z nazwy programu, który chcemy uruchomić i jego argumentów. Dodatkowo można określić, czy i gdzie kierować informacje ze standardowych strumieni wejścia/wyjścia procesu.

\begin{lstlisting} [language=Python]
proces = Popen(["fswebcam", "-q", "-d/dev/video0", "-r 640x480", "/var/www/html/img/2018-05-24 22:32:10.jpg"], stdout=PIPE, stderr=PIPE)
\end{lstlisting}

Użytymi argumentami programu \texttt{fswebcam} w powyższym przykładowym wywołaniu są:
\begin{itemize}
\item \texttt{-r} -- rozdzielczość , 
\item \texttt{-d} -- nazwa wirtualnego węzła kamery,
\item \texttt{-q} -- tryb cichy,
\item ścieżka, gdzie zdjęcie ma być zapisane.
\end{itemize}
Standardowe strumienie wyjścia i błędów są przekierowane do obiektów \texttt{pipe}, dzięki czemu ich wartość będzie można następnie odczytać. Program \texttt{fswebcam} domyślnie przekierowuje wszystkie komunikaty do strumienia błędów. Użycie trybu cichego zapewnia, że w strumieniu błędów znajdzie się jedynie informacja o błędach.

Zdjęcie jest zapisywane w formacie JPG w rozdzielczości 640x480 pikseli. Jest to maksymalna przetestowana możliwa rozdzielczość kamery Titanum Onyx. Kolejną komendą jest nazwa wirtualnego węzła kamery (ang. \textit{virtual device node}). Jest to plik, który system Linux tworzy podczas uruchomienia i który jest przypisany do konkretnego urządzenia. Plik ten jest przechowywany w folderze \texttt{/dev}. Dzięki użyciu wirtualnego węzła możliwe jest wskazanie konkretnej kamery do wykonania zdjęcia. Zdjęcie jest zapisywane w miejscu wskazanym przez atrybut klasy Grupa o nazwie sciezka. Do przekazywanej do programu ścieżki dołączana jest nazwa zdjęcia w postaci daty zaplanowania jego wykonania. Format daty to "'rok-miesiąc-dzień godzina:minuta:sekunda"' i stanowi unikalny identyfikator zdjęcia. Jest to możliwe, ponieważ w jednej chwili czasu działa wyłącznie jedno wywołanie funkcji \texttt{wyslij{\_}zdjecie()}.

Po wywołaniu procesu funkcja oczekuje na jego wykonanie i odbiera informacje ze strumienia wyjścia i błędów przy pomocy metody \texttt{communicate()}. Jeśli zawartość strumienia błędów nie jest pusta, podniesiony jest wyjątek \texttt{IOError}. Na tej podstawie podejmowana jest decyzja o nazwie zdjęcia, która będzie zapisana do bazy danych. 
\subsection{Obsługa czujników podłączonych do magistrali I2C}
\subsubsection{Komunikacja z multiplekserem TCA9548A}
Multiplekser TCA9548A umożliwia podłączenie do 8 urządzeń korzystających z magistrali I2C. Użyte czujniki temperatury i wilgotności Si 7021 posiadają taki sam adres, więc multiplekser powinien być skonfigurowany do zestawienia komunikacji z każdym z nich osobno. Aktywacja pojedynczego kanału odbywa się poprzez przesłanie do multipleksera 8 bitowego kodu odpowiadającego jego numerowi. Kod tworzony jest przez ustawienie bitu o pozycji równej numerowi kanału jako 1. Pozostałe pola powinny być ustawione jako 0. Definicja bajtu sterującego została pokazana w tabeli \ref{command_byte}. Operację tą wykonuje pomocnicza funkcja \texttt{kanal}. Zwraca ona 8 bitową komendę odpowiadającą numerowi kanału. Po wysłaniu komendy i znaku STOP kanał jest aktywowany. Kolejne komendy można adresować, używając adresu czujnika temperatury.
\begin{table}[h]
\centering
\begin{tabular}{|llllllll|l|}
\hline
\multicolumn{8}{|l|}{Bity rejestru sterującego}                                                                                                                                                                                                                                                                                                                                                & \multicolumn{1}{c|}{\multirow{2}{*}{Działanie}}                              \\ \cline{1-8}
B7                                          & B6                                            & B5                                            & B4                                            & B3                                            & B2                                            & B1                                            & \multicolumn{1}{l}{B0}                       & \multicolumn{1}{|c|}{}                                                        \\ \hline
X                                             & X                                             & X                                             & X                                             & X                                             & X                                             & X                                             & \begin{tabular}[c]{@{}l@{}}0\\ 1\end{tabular} & \begin{tabular}[c]{@{}l@{}}Kanał 0 nieaktywny\\ Kanał 0 aktywny\end{tabular} \\ \hline
X                                             & X                                             & X                                             & X                                             & X                                             & X                                             & \begin{tabular}[c]{@{}l@{}}0\\ 1\end{tabular} & X                                             & \begin{tabular}[c]{@{}l@{}}Kanał 1 nieaktywny\\ Kanał 1 aktywny\end{tabular} \\ \hline
X                                             & X                                             & X                                             & X                                             & X                                             & \begin{tabular}[c]{@{}l@{}}0\\ 1\end{tabular} & X                                             & X                                             & \begin{tabular}[c]{@{}l@{}}Kanał 2 nieaktywny\\ Kanał 2 aktywny\end{tabular} \\ \hline
X                                             & X                                             & X                                             & X                                             & \begin{tabular}[c]{@{}l@{}}0\\ 1\end{tabular} & X                                             & X                                             & X                                             & \begin{tabular}[c]{@{}l@{}}Kanał 3 nieaktywny\\ Kanał 3 aktywny\end{tabular} \\ \hline
X                                             & X                                             & X                                             & \begin{tabular}[c]{@{}l@{}}0\\ 1\end{tabular} & X                                             & X                                             & X                                             & X                                             & \begin{tabular}[c]{@{}l@{}}Kanał 4 nieaktywny\\ Kanał 4 aktywny\end{tabular} \\ \hline
X                                             & X                                             & \begin{tabular}[c]{@{}l@{}}0\\ 1\end{tabular} & X                                             & X                                             & X                                             & X                                             & X                                             & \begin{tabular}[c]{@{}l@{}}Kanał 5 nieaktywny\\ Kanał 5 aktywny\end{tabular} \\ \hline
X                                             & \begin{tabular}[c]{@{}l@{}}0\\ 1\end{tabular} & X                                             & X                                             & X                                             & X                                             & X                                             & X                                             & \begin{tabular}[c]{@{}l@{}}Kanał 6 nieaktywny\\ Kanał 6 aktywny\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}0\\ 1\end{tabular} & X                                             & X                                             & X                                             & X                                             & X                                             & X                                             & X                                             & \begin{tabular}[c]{@{}l@{}}Kanał 7 nieaktywny\\ Kanał 7 aktywny\end{tabular} \\ \hline
\end{tabular}
\caption{Definicja bajtu sterującego. Źródło: \cite{multiplekser}}
\label{command_byte}
\end{table}

\subsubsection{Komunikacja z czujnikiem Si7021}
Pierwszą komendą, którą należy wysłać do czujnika, jest komenda pomiaru wilgotności względnej. W dokumentacji czujnika Si7021 opisane są dwie metody pomiaru - Hold Master Mode oraz No Hold Master Mode. Ich porównanie zostało przedstawione na rysunku \ref{fig: metody_pomiaru}. Kolorem białym są oznaczone komendy wysyłane przez urządzenie nadrzędne (ang. \textit{master}), a szarym przez urządzenie podrzędne (ang. \textit{slave}). W pierwszej z nich urządzenie nadrzędne wysyła żądanie pomiaru (bajt \textit{Measure Cmd}). Po potwierdzeniu odbioru wysyłane jest żądanie odczytu (znak \textit{R}) Urządzenie podrzędne potwierdza otrzymanie żądania i dokonuje pomiaru. Wymaga to zastosowania rozciągania zegara (ang. \textit{clock stretching}), które polega na utrzymywaniu przez urządzenie podrzędne linii zegarowej SCK w stanie niskim. Dzieje się to do momentu zakończenia pomiaru przez urządzenie i wystawieniu jego wyniku do rejestru. Wynik pomiaru składa się z dwóch bajtów, które należy odebrać w jednej transakcji. Następnie komunikacja kończy się poprzez wystawienie znaku STOP (znak \textit{P}). Drugi tryb pomiaru (No Hold Master Mode) różni się tym, że po wysłaniu kodu pomiaru (0xF5) oraz żądania odczytu urządzenie nie potwierdza odbioru do momentu zakończenia konwersji pomiaru. Następnie należy odczytać dwubajtowy wynik pomiaru z rejestru czujnika.

\begin{figure}[H]
\begin{center}
\includegraphics[width=0.8\linewidth]{Si7021_pomiar.png}
\caption{Porównanie sekwencji komend I2C do wykonania pomiaru czujnikiem Si7021. Źródło: \cite{czujnik_temp}}
\label{fig: metody_pomiaru}
\end{center}
\end{figure}

Do programistycznej komunikacji poprzez I2C potrzebna była odpowiednia bibliotek. Pierwszym zastosowanym modułem był python-smbus. Korzysta on ze sterownika wbudowanego w jądro systemu Linux. Do przeprowadzenia pomiaru w trybie Hold Master Mode można użyć funkcji \texttt{i2c{\_}smbus{\_}read{\_}word{\_}data()} \linebreak lub\texttt{i2c{\_}smbus{\_}read{\_}i2c{\_}block{\_}data()}. Obie są zgodne z przedstawioną powyżej sekwencją pomiaru. Różnią się liczbą odebranych bajtów. Pierwsza funkcja odbiera dokładnie dwa bajty, a druga odbiera bajty z urządzenia do momentu zakończenia komunikacji przez urządzenie podrzędne\cite{smbus}. Próba przeprowadzenia pomiaru przy ich użyciu zakończyła się błędem o kodzie \texttt{io errno5}. Wynikał on z tego, że pakiet smbus obsługuje magistralę I2C zgodnie ze standardem SMBus -- rozszerzeniem I2C. Posiada on bardziej ścisłe reguły dotyczące czasu trwania transakcji na magistrali. Obie wymienione funkcje odczytu pakietu python-smbus są poprzedzone wysłaniem żądania do urządzenia. Oznacza to, że nie można przy ich pomocy odczytać samego wyniku pomiaru po wysłaniu kodu pomiaru w trybie No Hold Master Mode (0xE5). Inna dostępna funkcja \texttt{i2c{\_}smbus{\_}read{\_}byte()} pozwala na odczyt wyłącznie jednego bajtu. Dwukrotne wysłanie żądania przy pomocy tej funkcji prowadzi do dwukrotnego odczytania pierwszego bajtu pomiaru. 

Innym pakietem umożliwiającym komunikację poprzez magistralę I2C jest pigpio. Umożliwia on obsługę wyprowadzeń GPIO na Raspberry Pi w tym tych, które są skonfigurowane jako magistrala I2C. Opiera on swoje działanie na bibliotece napisanej w języku C. Przed rozpoczęciem działania z pakietu konieczne jest uruchomienie programu pidpiod. Jest to demon -- program działający w tle bez interakcji z użytkownikiem. Musi on działać, zanim wywołany zostanie program nadzor.py. Można to zapewnić, korzystając z narzędzia \texttt{cron}. Wpis do jego tabeli z wywołaniem programu pigpiod poprzedzony \texttt{@reboot} umieszczony przed podobnym wpisem programu nadzor.py zapewnia, że program zostanie uruchomiony za każdym razem, gdy włączany będzie system operacyjny.

Pierwszym krokiem jest stworzenie obiektu klasy \texttt{pigpio.pi}. Obiekt ten jest przechowywany jako atrybut \textit{i2c} klasy Grupa. Następnie konieczne jest otwarcie komunikacji z urządzeniem i zwrócenie identyfikatora, który będzie używany do wysyłania żądań do urządzeń. Funkcje tego modułu umożliwiają przeprowadzenie pomiaru wilgotności względnej w trybie \textit{No Hold Master Mode}. W pierwszej kolejności wysyłana jest przy pomocy funkcji \texttt{i2c{\_}write{\_}byte()} 8-bitowa komenda pomiaru. Realizuje ona sekwencję pomiaru do momentu potwierdzenia odbioru komendy przez urządzenie podrzędne. Następnie urządzenie oczekuje znaku powtórzonego startu (\textit{Sr}). Dopuszczalne jest jednak przesłanie znaku STOP i zakończenie komunikacji.

Następnie program jest usypiany na 0.05s przy pomocy komendy \texttt{time.sleep()}. Jest to wartość większa niż najdłuższy czas konwersji pomiaru wilgotności względnej podany w karcie katalogowej czujnika Si 7021. W tym czasie zachodzi konwersja pomiaru i można przejść do tej części procedury, która składa się z wysłaniu bitu odczytu (\textit{R}) i odebrania dwóch bajtów wyniku pomiaru. Można to zrealizować poprzez funkcję \texttt{i2c{\_}read{\_}device()}\cite{i2c_read_device}. Funkcja zwraca liczbę odczytanych bajtów i bajty w formie tablicy. Bajty te można następnie wykorzystać do obliczenia wilgotności względnej na podstawie wzoru \ref{RH} podanego w karcie katalogowej. ${Kod_{RH}}$ oznacza tablicę bajtów, do której został zapisany wynik pomiaru.
\begin{equation} \label{RH}
\%RH = \frac{(Kod_{RH}[0] * 256 + Kod_{RH}[1]) * 125}{65536} - 6  
\end{equation}

Czujnik Si 7021 wykonuje pomiar temperatury w ramach procedury wyznaczenia wilgotności względnej. Wynik tego pomiaru jest przechowywany w urządzeniu. Można go odczytać, wysyłając komendę o kodzie 0xE0. Całą transakcję można zrealizować przy użyciu funkcji \texttt{i2c{\_}read{\_}i2c{\_}block{\_}data} bez obawy o rozciąganie zegara, ponieważ nie ma potrzeby oczekiwania na konwersję pomiaru temperatury. Dwa bajty wyniku pomiaru są zapisane do tablicy i użyte do obliczenia wartości temperatury na podstawie wzoru \ref{Temperatura}.
\begin{equation} \label{Temperatura}
Temperatura ({^\circ}C) = \frac{(Kod_{temp}[0] * 256 + Kod_{temp}[1]) * 175,72}{65536} - 46,85  
\end{equation}

Obsługa wyjątków w połączeniu z multiplekserem jest przeprowadzona poprzez wypisanie do konsoli komunikatu o typie urządzenia, dla którego nastąpił błąd (multiplekser albo czujnik). W takim wypadku wartościom temperatury i wilgotności są przypisywane wartości None. Po zakończeniu pomiaru wynik zostaje zapisany w bazie danych.

\subsection{Obsługa czujników stykowych}
Korzystanie z wyprowadzeń GPIO w języku Python jest możliwe na komputerze Raspberry Pi przy użyciu pakietu \texttt{RPi.GPIO}. Umożliwia on odczyt stanu wyprowadzeń. Konfiguracja obsługi GPIO rozpoczyna się od określenia sposobu numeracji wyprowadzeń. Dostępne są dwie możliwości: GPIO.BOARD oraz GPIO.BCM. Pierwszy odnosi się do fizycznej lokalizacji wyprowadzeń na płytce drukowanej. Drugi sposób oznacza numeracją kanałów system-on-chip (SOC) firmy Broadcom, który jest użyty w komputerze Raspberry Pi 3B. Ze względu na korzystanie z płytki prototypowej oraz modułu Proto Pi Plus, który korzysta z oznaczeń odpowiadających kanałom SOC w projekcie użyto tego sposobu numeracji.

Inicjalizacja obsługi GPIO wywoływana jest w funkcji:  
\begin{lstlisting} [language=Python]
def init_gpio():
    GPIO.setmode(GPIO.BCM)
\end{lstlisting}
Wykonywana jest ona na początku działania programu \texttt{nadzor.py} w funkcji \texttt{main()}. Obsługa poszczególnych czujników odbywa się w ramach obiektów klasy Grupa. Użycie rezystora ściągającego jest wywoływane w programie \texttt{nadzor.py} w konstruktorze obiektu klasy Grupa w następujący sposób.
\begin{lstlisting} [language=Python]
GPIO.setup(self.czujnik.gpio, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)
\end{lstlisting}
Pierwszym argumentem tej funkcji jest numer wyprowadzenia GPIO, drugi określa, czy wyprowadzenie ma być skonfigurowane jako wejście (\texttt{GPIO.IN}) czy wyjście (\texttt{GPIO.OUT}). Trzeci argument to znacznik określający, czy ma zostać użyty rezystor ściągający czy podciągający.

Funkcja realizująca obsługę czujników stykowych zaczyna od sprawdzenia wyprowadzenia o numerze przechowywanym jako atrybut klasy. Zwrócenie stanu wysokiego (oznaczanego jako \texttt{1/GPIO.HIGH/True}) oznacza przypisanie do zmiennej \texttt{stan{\_}czujnika} wartości 1. Jeśli stan jest niski, zmiennej przypisywane jest 0. Następnie sprawdzany jest poprzedni stan wyprowadzenia przechowywany jako atrybut obiektu klasy Grupa. Jeśli poprzednio stan był wysoki (czujniki były zbliżone), to znaczy, że nastąpiło otwarcie czujników. Zgodnie z wymogami systemu następuję wywołanie zdjęcia - funkcji obsługującej kamery. Dodatkowo program przechodzi do wysłania powiadomienia email.

\subsection{Wysyłanie powiadomień e-mail}
Funkcjonalnością systemu jest również wysyłanie powiadomienia mailowego po otwarciu czujnika. Jest ono realizowane poprzez serwer SMTP Google. Ta decyzja projektowa wynika z tego, że konfiguracja serwera SMTP działającego na Raspberry Pi wymagałoby posiadania stałego adresu IP dostarczanego przez dostawcę usług internetowych oraz domeny, która będzie przypisana do tego adresu. Prostszym rozwiązaniem jest utworzenie konta email w zewnętrznej usłudze (np. Gmail) i korzystanie z jej serwera SMTP. 

Połączenie z serwerem SMTP Google jest nawiązywane przy użyciu modułu \texttt{smtplib} na początku działania programu nadzor.py. 
\begin{lstlisting} [language=Python]
def init_smtp(sender, password):
    smtp_server = smtplib.SMTP_SSL("smtp.gmail.com", 465)
    smtp_server.login(sender, password)
    return smtp_server 
\end{lstlisting}
Wymogiem Gmaila jest stosowanie szyfrowanego połączenia SSL, które jest nawiązywane przez funkcję \texttt{SMTP{\_}SSL}. Komunikacja odbywa się na standardowym dla tego połączenia porcie 465. Następnie dokonuje się uwierzytelnienie użytkownika na serwerze poprzez przesłanie adresu email konta, z którego mają być wysyłane wiadomości oraz hasła do niego. Funkcja zwraca referencję obiektu reprezentującego połączenie z serwerem SMTP.

W przypadku gdy zostanie otwarty czujnik stykowy oprócz wykonania zdjęcia, sprawdzany jest stan znacznika powiadomień e-mail. Jeśli jest on równy "'on"', a adres e-mail odbiorcy powiadomień nie jest pusty, rozpoczyna się procedura wysłania powiadomienia. Przygotowany jest tekst wiadomości zawierający informację o otwarciu czujniku i przypisanej mu nazwie. Na temat wiadomości składa się informacja o otwarciu czujnika i dacie i godzinie otwarcia. Następnie zostaje otworzony nowy wątek, w którym jest wywoływana funkcja \texttt{wyslij{\_}email()}. Argumentami tej funkcji są adres e-mail odbiorcy, temat wiadomości, jej tekst oraz nazwa zdjęcia, która będzie dołączona jako załącznik. Do otwarcia wątku użyta jest pomocnicza funkcja \texttt{run{\_}threaded}. Użycie wątku zapewnia, że funkcja wysyłająca powiadomienie jest wykonywana współbieżnie z pozostałymi funkcjami sprawdzającymi stany czujników.

Do stworzenia wiadomości e-mail jest wykorzystany obiekt klasy \texttt{MIMEMultipart}. Reprezentuje ona wieloczęściową wiadomość e-mail zgodną ze standardem MIME (ang. \textit{Multipurpose Internet Mail Extensions}\cite{mime1}\cite{mime2}.  W polach \texttt{Subject}, \texttt{To} i \texttt{From} zostają wpisane odpowiednio temat, odbiorca i nadawca wiadomości e-mail. Następnie funkcja otwiera plik ze zdjęciem, które zostało wywołane przez otwarcie czujnika i tworzony jest obiekt MIMEImage, który reprezentuje część wiadomości będącej obrazem. Nie jest tu podawany format zdjęcia, ponieważ obiekt sam dokona sprawdzenia typu zdjęcia przy pomocy modułu \texttt{imghdr}\cite{python-mime}. Dzięki temu zmiana formatu zdjęcia np. z JPEG na PNG nie wymaga zmiany tej części kodu. Przed dołączeniem do wiadomości pliku ze zdjęciem konieczne jest również ustawienie nagłówka \texttt{Content-Disposition} z informacją o tym, że jest to załącznik (\textit{attachment}) oraz o jego nazwie. Dzięki temu obraz zostanie wyświetlony jako załącznik do pobrania w kliencie poczty elektronicznej.\cite{content-disposition}. Po dołączeniu załączników następuje wysłanie wiadomości e-mail.
\newpage
\section{Bibliografia}
\begin{thebibliography}{9}
\bibitem{multiplekser}
Karta katalogowa multipleksera TCA9548A:
\url{http://www.ti.com/lit/ds/symlink/tca9548a.pdf}

\bibitem{czujnik_temp}
Karta katalogowa czujnika temperatury i wilgotności Si7021:
\url{https://www.silabs.com/documents/public/data-sheets/Si7021-A20.pdf}

\bibitem{smbus}
Opis protokołu SMBus
\url{https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/plain/Documentation/i2c/smbus-protocol}

\bibitem{i2c_read_device}
Dokumentacja funkcji \texttt{i2c{\_}read{\_}device()}
\url{http://abyz.me.uk/rpi/pigpio/python.html#i2c_read_device}

\bibitem{mime1}
Freed N., Borenstein N., Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies, RFC 2045, IETF, listopad 1996, DOI: 10.17487/RFC2045.
\url{https://tools.ietf.org/html/rfc2045}

\bibitem{mime2}
Freed N., Borenstein N., Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types, RFC 2046, IETF, listopad 1996, DOI: 10.17487/RFC2046.
\url{https://tools.ietf.org/html/rfc2046}

\bibitem{content-disposition}

\url{https://tools.ietf.org/html/rfc6266}
Reschke J. Use of the Content-Disposition Header Field in the Hypertext Transfer Protocol (HTTP)
\bibitem{python-mime}
Dokumentacja modułu Python email.mime
\url{https://docs.python.org/3/library/email.mime.html}


\end{thebibliography}

\end{document}
